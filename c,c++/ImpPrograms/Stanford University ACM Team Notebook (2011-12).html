<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>Stanford University ACM Team Notebook (2011-12)</title>
</head>
<body bgcolor="#FFFFFF" link="#1F00FF" text="#000000" vlink="#9900DD" alink="#FF0000">
<div id="dic_bubble" class="selection_bubble fontSize13 noSelect" style="z-index:9999; border: 1px solid #4AAEDE;fetching=false"></div><a name="top">
<center><h1><u>Stanford University ACM Team Notebook (2011-12)</u></h1></center>
<h1>Table of Contents</h1>
<h2>Combinatorial optimization</h2>

</a><ol start="1"><a name="top">
</a><li><a name="top"></a><a href="#file1">Sparse max-flow (C++)</a></li>
<li><a href="#file2">Min-cost max-flow (C++)</a></li>
<li><a href="#file3">Push-relabel max-flow (C++)</a></li>
<li><a href="#file4">Min-cost matching (C++)</a></li>
<li><a href="#file5">Max bipartite matching (C++)</a></li>
<li><a href="#file6">Global min cut (C++)</a></li>
</ol>
<h2>Geometry</h2>

<ol start="7">
<li><a href="#file7">Convex hull (C++)</a></li>
<li><a href="#file8">Miscellaneous geometry (C++)</a></li>
<li><a href="#file9">Java geometry (Java)</a></li>
<li><a href="#file10">3D geometry (Java)</a></li>
<li><a href="#file11">Slow Delaunay triangulation (C++)</a></li>
</ol>
<h2>Numerical algorithms</h2>

<ol start="12">
<li><a href="#file12">Number theoretic algorithms (modular, Chinese remainder, linear Diophantine) (C++)</a></li>
<li><a href="#file13">Systems of linear equations, matrix inverse, determinant (C++)</a></li>
<li><a href="#file14">Reduced row echelon form, matrix rank (C++)</a></li>
<li><a href="#file15">Fast Fourier transform (C++)</a></li>
<li><a href="#file16">Simplex algorithm (C++)</a></li>
</ol>
<h2>Graph algorithms</h2>

<ol start="17">
<li><a href="#file17">Fast Dijkstra's algorithm (C++)</a></li>
<li><a href="#file18">Strongly connected components (C)</a></li>
</ol>
<h2>Data structures</h2>

<ol start="19">
<li><a href="#file19">Suffix arrays (C++)</a></li>
<li><a href="#file20">Binary Indexed Tree</a></li>
<li><a href="#file21">Union-Find Set (C/C++)</a></li>
<li><a href="#file22">KD-tree (C++)</a></li>
</ol>
<h2>Miscellaneous</h2>

<ol start="23">
<li><a href="#file23">Longest increasing subsequence (C++)</a></li>
<li><a href="#file24">Dates (C++)</a></li>
<li><a href="#file25">Regular expressions (Java)</a></li>
<li><a href="#file26">Prime numbers (C++)</a></li>
<li><a href="#file27">Knuth-Morris-Pratt (C++)</a></li>
</ol>
<hr>
<a name="file1">
<h1>Dinic.cc 1/27</h1>
<pre><i><font color="#B22222">// Adjacency list implementation of Dinic's blocking flow algorithm.
</font></i><i><font color="#B22222">// This is very fast in practice, and only loses to push-relabel flow.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time:
</font></i><i><font color="#B22222">//     O(|V|^2 |E|)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT: 
</font></i><i><font color="#B22222">//     - graph, constructed using AddEdge()
</font></i><i><font color="#B22222">//     - source
</font></i><i><font color="#B22222">//     - sink
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:
</font></i><i><font color="#B22222">//     - maximum flow value
</font></i><i><font color="#B22222">//     - To obtain the actual flow values, look at all edges with
</font></i><i><font color="#B22222">//       capacity &gt; 0 (zero capacity edges are residual edges).
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;queue&gt;</b></font>

using namespace std;

<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> INF = 2000000000;

<font color="#228B22"><b>struct</b></font> Edge {
  <font color="#228B22"><b>int</b></font> from, to, cap, flow, index;
  Edge(<font color="#228B22"><b>int</b></font> from, <font color="#228B22"><b>int</b></font> to, <font color="#228B22"><b>int</b></font> cap, <font color="#228B22"><b>int</b></font> flow, <font color="#228B22"><b>int</b></font> index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};

<font color="#228B22"><b>struct</b></font> Dinic {
  <font color="#228B22"><b>int</b></font> N;
  vector&lt;vector&lt;Edge&gt; &gt; G;
  vector&lt;Edge *&gt; dad;
  vector&lt;<font color="#228B22"><b>int</b></font>&gt; Q;
  
  Dinic(<font color="#228B22"><b>int</b></font> N) : N(N), G(N), dad(N), Q(N) {}
  
  <font color="#228B22"><b>void</b></font> AddEdge(<font color="#228B22"><b>int</b></font> from, <font color="#228B22"><b>int</b></font> to, <font color="#228B22"><b>int</b></font> cap) {
    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
    <b><font color="#A020F0">if</font></b> (from == to) G[from].back().index++;
    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
  }

  <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> BlockingFlow(<font color="#228B22"><b>int</b></font> s, <font color="#228B22"><b>int</b></font> t) {
    fill(dad.begin(), dad.end(), (Edge *) NULL);
    dad[s] = &amp;G[0][0] - 1;
    
    <font color="#228B22"><b>int</b></font> head = 0, tail = 0;
    Q[tail++] = s;
    <b><font color="#A020F0">while</font></b> (head &lt; tail) {
      <font color="#228B22"><b>int</b></font> x = Q[head++];
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; G[x].size(); i++) {
	Edge &amp;e = G[x][i];
	<b><font color="#A020F0">if</font></b> (!dad[e.to] &amp;&amp; e.cap - e.flow &gt; 0) {
	  dad[e.to] = &amp;G[x][i];
	  Q[tail++] = e.to;
	}
      }
    }
    <b><font color="#A020F0">if</font></b> (!dad[t]) <b><font color="#A020F0">return</font></b> 0;

    <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> totflow = 0;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; G[t].size(); i++) {
      Edge *start = &amp;G[G[t][i].to][G[t][i].index];
      <font color="#228B22"><b>int</b></font> amt = INF;
      <b><font color="#A020F0">for</font></b> (Edge *e = start; amt &amp;&amp; e != dad[s]; e = dad[e-&gt;from]) {
	<b><font color="#A020F0">if</font></b> (!e) { amt = 0; <b><font color="#A020F0">break</font></b>; }
	amt = min(amt, e-&gt;cap - e-&gt;flow);
      }
      <b><font color="#A020F0">if</font></b> (amt == 0) <b><font color="#A020F0">continue</font></b>;
      <b><font color="#A020F0">for</font></b> (Edge *e = start; amt &amp;&amp; e != dad[s]; e = dad[e-&gt;from]) {
	e-&gt;flow += amt;
	G[e-&gt;to][e-&gt;index].flow -= amt;
      }
      totflow += amt;
    }
    <b><font color="#A020F0">return</font></b> totflow;
  }

  <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> GetMaxFlow(<font color="#228B22"><b>int</b></font> s, <font color="#228B22"><b>int</b></font> t) {
    <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> totflow = 0;
    <b><font color="#A020F0">while</font></b> (<font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> flow = BlockingFlow(s, t))
      totflow += flow;
    <b><font color="#A020F0">return</font></b> totflow;
  }
};

</pre>
<hr>
</a><a name="file2">
<h1>MinCostMaxFlow.cc 2/27</h1>
<pre><i><font color="#B22222">// Implementation of min cost max flow algorithm using adjacency
</font></i><i><font color="#B22222">// matrix (Edmonds and Karp 1972).  This implementation keeps track of
</font></i><i><font color="#B22222">// forward and reverse edges separately (so you can set cap[i][j] !=
</font></i><i><font color="#B22222">// cap[j][i]).  For a regular max flow, set all edge costs to 0.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time, O(|V|^2) cost per augmentation
</font></i><i><font color="#B22222">//     max flow:           O(|V|^3) augmentations
</font></i><i><font color="#B22222">//     min cost max flow:  O(|V|^4 * MAX_EDGE_COST) augmentations
</font></i><i><font color="#B22222">//     
</font></i><i><font color="#B22222">// INPUT: 
</font></i><i><font color="#B22222">//     - graph, constructed using AddEdge()
</font></i><i><font color="#B22222">//     - source
</font></i><i><font color="#B22222">//     - sink
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:
</font></i><i><font color="#B22222">//     - (maximum flow value, minimum cost value)
</font></i><i><font color="#B22222">//     - To obtain the actual flow, look at positive values only.
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;
<font color="#228B22"><b>typedef</b></font> vector&lt;VI&gt; VVI;
<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> L;
<font color="#228B22"><b>typedef</b></font> vector&lt;L&gt; VL;
<font color="#228B22"><b>typedef</b></font> vector&lt;VL&gt; VVL;
<font color="#228B22"><b>typedef</b></font> pair&lt;<font color="#228B22"><b>int</b></font>, <font color="#228B22"><b>int</b></font>&gt; PII;
<font color="#228B22"><b>typedef</b></font> vector&lt;PII&gt; VPII;

<font color="#228B22"><b>const</b></font> L INF = numeric_limits&lt;L&gt;::max() / 4;

<font color="#228B22"><b>struct</b></font> MinCostMaxFlow {
  <font color="#228B22"><b>int</b></font> N;
  VVL cap, flow, cost;
  VI found;
  VL dist, pi, width;
  VPII dad;

  MinCostMaxFlow(<font color="#228B22"><b>int</b></font> N) : 
    N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)), 
    found(N), dist(N), pi(N), width(N), dad(N) {}
  
  <font color="#228B22"><b>void</b></font> AddEdge(<font color="#228B22"><b>int</b></font> from, <font color="#228B22"><b>int</b></font> to, L cap, L cost) {
    <b><font color="#A020F0">this</font></b>-&gt;cap[from][to] = cap;
    <b><font color="#A020F0">this</font></b>-&gt;cost[from][to] = cost;
  }
  
  <font color="#228B22"><b>void</b></font> Relax(<font color="#228B22"><b>int</b></font> s, <font color="#228B22"><b>int</b></font> k, L cap, L cost, <font color="#228B22"><b>int</b></font> dir) {
    L val = dist[s] + pi[s] - pi[k] + cost;
    <b><font color="#A020F0">if</font></b> (cap &amp;&amp; val &lt; dist[k]) {
      dist[k] = val;
      dad[k] = make_pair(s, dir);
      width[k] = min(cap, width[s]);
    }
  }

  L Dijkstra(<font color="#228B22"><b>int</b></font> s, <font color="#228B22"><b>int</b></font> t) {
    fill(found.begin(), found.end(), false);
    fill(dist.begin(), dist.end(), INF);
    fill(width.begin(), width.end(), 0);
    dist[s] = 0;
    width[s] = INF;
    
    <b><font color="#A020F0">while</font></b> (s != -1) {
      <font color="#228B22"><b>int</b></font> best = -1;
      found[s] = true;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; N; k++) {
        <b><font color="#A020F0">if</font></b> (found[k]) <b><font color="#A020F0">continue</font></b>;
        Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
        Relax(s, k, flow[k][s], -cost[k][s], -1);
        <b><font color="#A020F0">if</font></b> (best == -1 || dist[k] &lt; dist[best]) best = k;
      }
      s = best;
    }

    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; N; k++)
      pi[k] = min(pi[k] + dist[k], INF);
    <b><font color="#A020F0">return</font></b> width[t];
  }

  pair&lt;L, L&gt; GetMaxFlow(<font color="#228B22"><b>int</b></font> s, <font color="#228B22"><b>int</b></font> t) {
    L totflow = 0, totcost = 0;
    <b><font color="#A020F0">while</font></b> (L amt = Dijkstra(s, t)) {
      totflow += amt;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> x = t; x != s; x = dad[x].first) {
        <b><font color="#A020F0">if</font></b> (dad[x].second == 1) {
          flow[dad[x].first][x] += amt;
          totcost += amt * cost[dad[x].first][x];
        } <b><font color="#A020F0">else</font></b> {
          flow[x][dad[x].first] -= amt;
          totcost -= amt * cost[x][dad[x].first];
        }
      }
    }
    <b><font color="#A020F0">return</font></b> make_pair(totflow, totcost);
  }
};

</pre>
<hr>
</a><a name="file3">
<h1>PushRelabel.cc 3/27</h1>
<pre><i><font color="#B22222">// Adjacency list implementation of FIFO push relabel maximum flow
</font></i><i><font color="#B22222">// with the gap relabeling heuristic.  This implementation is
</font></i><i><font color="#B22222">// significantly faster than straight Ford-Fulkerson.  It solves
</font></i><i><font color="#B22222">// random problems with 10000 vertices and 1000000 edges in a few
</font></i><i><font color="#B22222">// seconds, though it is possible to construct test cases that
</font></i><i><font color="#B22222">// achieve the worst-case.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time:
</font></i><i><font color="#B22222">//     O(|V|^3)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT: 
</font></i><i><font color="#B22222">//     - graph, constructed using AddEdge()
</font></i><i><font color="#B22222">//     - source
</font></i><i><font color="#B22222">//     - sink
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:
</font></i><i><font color="#B22222">//     - maximum flow value
</font></i><i><font color="#B22222">//     - To obtain the actual flow values, look at all edges with
</font></i><i><font color="#B22222">//       capacity &gt; 0 (zero capacity edges are residual edges).
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;queue&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> LL;

<font color="#228B22"><b>struct</b></font> Edge {
  <font color="#228B22"><b>int</b></font> from, to, cap, flow, index;
  Edge(<font color="#228B22"><b>int</b></font> from, <font color="#228B22"><b>int</b></font> to, <font color="#228B22"><b>int</b></font> cap, <font color="#228B22"><b>int</b></font> flow, <font color="#228B22"><b>int</b></font> index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};

<font color="#228B22"><b>struct</b></font> PushRelabel {
  <font color="#228B22"><b>int</b></font> N;
  vector&lt;vector&lt;Edge&gt; &gt; G;
  vector&lt;LL&gt; excess;
  vector&lt;<font color="#228B22"><b>int</b></font>&gt; dist, active, count;
  queue&lt;<font color="#228B22"><b>int</b></font>&gt; Q;

  PushRelabel(<font color="#228B22"><b>int</b></font> N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}

  <font color="#228B22"><b>void</b></font> AddEdge(<font color="#228B22"><b>int</b></font> from, <font color="#228B22"><b>int</b></font> to, <font color="#228B22"><b>int</b></font> cap) {
    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
    <b><font color="#A020F0">if</font></b> (from == to) G[from].back().index++;
    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
  }

  <font color="#228B22"><b>void</b></font> Enqueue(<font color="#228B22"><b>int</b></font> v) { 
    <b><font color="#A020F0">if</font></b> (!active[v] &amp;&amp; excess[v] &gt; 0) { active[v] = true; Q.push(v); } 
  }

  <font color="#228B22"><b>void</b></font> Push(Edge &amp;e) {
    <font color="#228B22"><b>int</b></font> amt = <font color="#228B22"><b>int</b></font>(min(excess[e.from], LL(e.cap - e.flow)));
    <b><font color="#A020F0">if</font></b> (dist[e.from] &lt;= dist[e.to] || amt == 0) <b><font color="#A020F0">return</font></b>;
    e.flow += amt;
    G[e.to][e.index].flow -= amt;
    excess[e.to] += amt;    
    excess[e.from] -= amt;
    Enqueue(e.to);
  }
  
  <font color="#228B22"><b>void</b></font> Gap(<font color="#228B22"><b>int</b></font> k) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> v = 0; v &lt; N; v++) {
      <b><font color="#A020F0">if</font></b> (dist[v] &lt; k) <b><font color="#A020F0">continue</font></b>;
      count[dist[v]]--;
      dist[v] = max(dist[v], N+1);
      count[dist[v]]++;
      Enqueue(v);
    }
  }

  <font color="#228B22"><b>void</b></font> Relabel(<font color="#228B22"><b>int</b></font> v) {
    count[dist[v]]--;
    dist[v] = 2*N;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; G[v].size(); i++) 
      <b><font color="#A020F0">if</font></b> (G[v][i].cap - G[v][i].flow &gt; 0)
	dist[v] = min(dist[v], dist[G[v][i].to] + 1);
    count[dist[v]]++;
    Enqueue(v);
  }

  <font color="#228B22"><b>void</b></font> Discharge(<font color="#228B22"><b>int</b></font> v) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; excess[v] &gt; 0 &amp;&amp; i &lt; G[v].size(); i++) Push(G[v][i]);
    <b><font color="#A020F0">if</font></b> (excess[v] &gt; 0) {
      <b><font color="#A020F0">if</font></b> (count[dist[v]] == 1) 
	Gap(dist[v]); 
      <b><font color="#A020F0">else</font></b>
	Relabel(v);
    }
  }

  LL GetMaxFlow(<font color="#228B22"><b>int</b></font> s, <font color="#228B22"><b>int</b></font> t) {
    count[0] = N-1;
    count[N] = 1;
    dist[s] = N;
    active[s] = active[t] = true;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; G[s].size(); i++) {
      excess[s] += G[s][i].cap;
      Push(G[s][i]);
    }
    
    <b><font color="#A020F0">while</font></b> (!Q.empty()) {
      <font color="#228B22"><b>int</b></font> v = Q.front();
      Q.pop();
      active[v] = false;
      Discharge(v);
    }
    
    LL totflow = 0;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; G[s].size(); i++) totflow += G[s][i].flow;
    <b><font color="#A020F0">return</font></b> totflow;
  }
};

</pre>
<hr>
</a><a name="file4">
<h1>MinCostMatching.cc 4/27</h1>
<pre><i><font color="#B22222">///////////////////////////////////////////////////////////////////////////
</font></i><i><font color="#B22222">// Min cost bipartite matching via shortest augmenting paths
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// This is an O(n^3) implementation of a shortest augmenting path
</font></i><i><font color="#B22222">// algorithm for finding min cost perfect matchings in dense
</font></i><i><font color="#B22222">// graphs.  In practice, it solves 1000x1000 problems in around 1
</font></i><i><font color="#B22222">// second.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//   cost[i][j] = cost for pairing left node i with right node j
</font></i><i><font color="#B22222">//   Lmate[i] = index of right node that left node i pairs with
</font></i><i><font color="#B22222">//   Rmate[j] = index of left node that right node j pairs with
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// The values in cost[i][j] may be positive or negative.  To perform
</font></i><i><font color="#B22222">// maximization, simply negate the cost[][] matrix.
</font></i><i><font color="#B22222">///////////////////////////////////////////////////////////////////////////
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;algorithm&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cstdio&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>double</b></font>&gt; VD;
<font color="#228B22"><b>typedef</b></font> vector&lt;VD&gt; VVD;
<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;

<font color="#228B22"><b>double</b></font> <b><font color="#0000FF">MinCostMatching</font></b>(<font color="#228B22"><b>const</b></font> VVD &amp;cost, VI &amp;Lmate, VI &amp;Rmate) {
  <font color="#228B22"><b>int</b></font> n = <font color="#228B22"><b>int</b></font>(cost.size());

  <i><font color="#B22222">// construct dual feasible solution
</font></i>  VD u(n);
  VD v(n);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) {
    u[i] = cost[i][0];
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 1; j &lt; n; j++) u[i] = min(u[i], cost[i][j]);
  }
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n; j++) {
    v[j] = cost[0][j] - u[0];
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 1; i &lt; n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
  }
  
  <i><font color="#B22222">// construct primal solution satisfying complementary slackness
</font></i>  Lmate = VI(n, -1);
  Rmate = VI(n, -1);
  <font color="#228B22"><b>int</b></font> mated = 0;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n; j++) {
      <b><font color="#A020F0">if</font></b> (Rmate[j] != -1) <b><font color="#A020F0">continue</font></b>;
      <b><font color="#A020F0">if</font></b> (fabs(cost[i][j] - u[i] - v[j]) &lt; 1e-10) {
	Lmate[i] = j;
	Rmate[j] = i;
	mated++;
	<b><font color="#A020F0">break</font></b>;
      }
    }
  }
  
  VD dist(n);
  VI dad(n);
  VI seen(n);
  
  <i><font color="#B22222">// repeat until primal solution is feasible
</font></i>  <b><font color="#A020F0">while</font></b> (mated &lt; n) {
    
    <i><font color="#B22222">// find an unmatched left node
</font></i>    <font color="#228B22"><b>int</b></font> s = 0;
    <b><font color="#A020F0">while</font></b> (Lmate[s] != -1) s++;
    
    <i><font color="#B22222">// initialize Dijkstra
</font></i>    fill(dad.begin(), dad.end(), -1);
    fill(seen.begin(), seen.end(), 0);
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; n; k++) 
      dist[k] = cost[s][k] - u[s] - v[k];
    
    <font color="#228B22"><b>int</b></font> j = 0;
    <b><font color="#A020F0">while</font></b> (true) {
      
      <i><font color="#B22222">// find closest
</font></i>      j = -1;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; n; k++) {
	<b><font color="#A020F0">if</font></b> (seen[k]) <b><font color="#A020F0">continue</font></b>;
	<b><font color="#A020F0">if</font></b> (j == -1 || dist[k] &lt; dist[j]) j = k;
      }
      seen[j] = 1;
      
      <i><font color="#B22222">// termination condition
</font></i>      <b><font color="#A020F0">if</font></b> (Rmate[j] == -1) <b><font color="#A020F0">break</font></b>;
      
      <i><font color="#B22222">// relax neighbors
</font></i>      <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> i = Rmate[j];
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; n; k++) {
	<b><font color="#A020F0">if</font></b> (seen[k]) <b><font color="#A020F0">continue</font></b>;
	<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>double</b></font> new_dist = dist[j] + cost[i][k] - u[i] - v[k];
	<b><font color="#A020F0">if</font></b> (dist[k] &gt; new_dist) {
	  dist[k] = new_dist;
	  dad[k] = j;
	}
      }
    }
    
    <i><font color="#B22222">// update dual variables
</font></i>    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; n; k++) {
      <b><font color="#A020F0">if</font></b> (k == j || !seen[k]) <b><font color="#A020F0">continue</font></b>;
      <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> i = Rmate[k];
      v[k] += dist[k] - dist[j];
      u[i] -= dist[k] - dist[j];
    }
    u[s] += dist[j];
    
    <i><font color="#B22222">// augment along path
</font></i>    <b><font color="#A020F0">while</font></b> (dad[j] &gt;= 0) {
      <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> d = dad[j];
      Rmate[j] = Rmate[d];
      Lmate[Rmate[j]] = j;
      j = d;
    }
    Rmate[j] = s;
    Lmate[s] = j;
    
    mated++;
  }
  
  <font color="#228B22"><b>double</b></font> value = 0;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++)
    value += cost[i][Lmate[i]];
  
  <b><font color="#A020F0">return</font></b> value;
}
</pre>
<hr>
</a><a name="file5">
<h1>MaxBipartiteMatching.cc 5/27</h1>
<pre><i><font color="#B22222">// This code performs maximum bipartite matching.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(|E| |V|) -- often much faster in practice
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//   INPUT: w[i][j] = edge between row node i and column node j
</font></i><i><font color="#B22222">//   OUTPUT: mr[i] = assignment for row node i, -1 if unassigned
</font></i><i><font color="#B22222">//           mc[j] = assignment for column node j, -1 if unassigned
</font></i><i><font color="#B22222">//           function returns number of matches made
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;
<font color="#228B22"><b>typedef</b></font> vector&lt;VI&gt; VVI;

<font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">FindMatch</font></b>(<font color="#228B22"><b>int</b></font> i, <font color="#228B22"><b>const</b></font> VVI &amp;w, VI &amp;mr, VI &amp;mc, VI &amp;seen) {
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; w[i].size(); j++) {
    <b><font color="#A020F0">if</font></b> (w[i][j] &amp;&amp; !seen[j]) {
      seen[j] = true;
      <b><font color="#A020F0">if</font></b> (mc[j] &lt; 0 || FindMatch(mc[j], w, mr, mc, seen)) {
        mr[i] = j;
        mc[j] = i;
        <b><font color="#A020F0">return</font></b> true;
      }
    }
  }
  <b><font color="#A020F0">return</font></b> false;
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">BipartiteMatching</font></b>(<font color="#228B22"><b>const</b></font> VVI &amp;w, VI &amp;mr, VI &amp;mc) {
  mr = VI(w.size(), -1);
  mc = VI(w[0].size(), -1);
  
  <font color="#228B22"><b>int</b></font> ct = 0;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; w.size(); i++) {
    VI seen(w[0].size());
    <b><font color="#A020F0">if</font></b> (FindMatch(i, w, mr, mc, seen)) ct++;
  }
  <b><font color="#A020F0">return</font></b> ct;
}
</pre>
<hr>
</a><a name="file6">
<h1>MinCut.cc 6/27</h1>
<pre><i><font color="#B22222">// Adjacency matrix implementation of Stoer-Wagner min cut algorithm.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time:
</font></i><i><font color="#B22222">//     O(|V|^3)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT: 
</font></i><i><font color="#B22222">//     - graph, constructed using AddEdge()
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:
</font></i><i><font color="#B22222">//     - (min cut value, nodes in half of min cut)
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;
<font color="#228B22"><b>typedef</b></font> vector&lt;VI&gt; VVI;

<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> INF = 1000000000;

pair&lt;<font color="#228B22"><b>int</b></font>, VI&gt; GetMinCut(VVI &amp;weights) {
  <font color="#228B22"><b>int</b></font> N = weights.size();
  VI used(N), cut, best_cut;
  <font color="#228B22"><b>int</b></font> best_weight = -1;
  
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> phase = N-1; phase &gt;= 0; phase--) {
    VI w = weights[0];
    VI added = used;
    <font color="#228B22"><b>int</b></font> prev, last = 0;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; phase; i++) {
      prev = last;
      last = -1;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 1; j &lt; N; j++)
	<b><font color="#A020F0">if</font></b> (!added[j] &amp;&amp; (last == -1 || w[j] &gt; w[last])) last = j;
      <b><font color="#A020F0">if</font></b> (i == phase-1) {
	<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; N; j++) weights[prev][j] += weights[last][j];
	<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; N; j++) weights[j][prev] = weights[prev][j];
	used[last] = true;
	cut.push_back(last);
	<b><font color="#A020F0">if</font></b> (best_weight == -1 || w[last] &lt; best_weight) {
	  best_cut = cut;
	  best_weight = w[last];
	}
      } <b><font color="#A020F0">else</font></b> {
	<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; N; j++)
	  w[j] += weights[last][j];
	added[last] = true;
      }
    }
  }
  <b><font color="#A020F0">return</font></b> make_pair(best_weight, best_cut);
}

</pre>
<hr>
</a><a name="file7">
<h1>ConvexHull.cc 7/27</h1>
<pre><i><font color="#B22222">// Compute the 2D convex hull of a set of points using the monotone chain
</font></i><i><font color="#B22222">// algorithm.  Eliminate redundant points from the hull if REMOVE_REDUNDANT is 
</font></i><i><font color="#B22222">// #defined.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(n log n)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//   INPUT:   a vector of input points, unordered.
</font></i><i><font color="#B22222">//   OUTPUT:  a vector of points in the convex hull, counterclockwise, starting
</font></i><i><font color="#B22222">//            with bottommost/leftmost point
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cstdio&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cassert&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;algorithm&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>

using namespace std;

#<b><font color="#5F9EA0">define</font></b> <font color="#B8860B">REMOVE_REDUNDANT</font>

<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>double</b></font> T;
<font color="#228B22"><b>const</b></font> T EPS = 1e-7;
<font color="#228B22"><b>struct</b></font> PT { 
  T x, y; 
  PT() {} 
  PT(T x, T y) : x(x), y(y) {}
  <font color="#228B22"><b>bool</b></font> <b><font color="#A020F0">operator</font></b>&lt;(<font color="#228B22"><b>const</b></font> PT &amp;rhs) <font color="#228B22"><b>const</b></font> { <b><font color="#A020F0">return</font></b> make_pair(y,x) &lt; make_pair(rhs.y,rhs.x); }
  <font color="#228B22"><b>bool</b></font> <b><font color="#A020F0">operator</font></b>==(<font color="#228B22"><b>const</b></font> PT &amp;rhs) <font color="#228B22"><b>const</b></font> { <b><font color="#A020F0">return</font></b> make_pair(y,x) == make_pair(rhs.y,rhs.x); }
};

T cross(PT p, PT q) { <b><font color="#A020F0">return</font></b> p.x*q.y-p.y*q.x; }
T area2(PT a, PT b, PT c) { <b><font color="#A020F0">return</font></b> cross(a,b) + cross(b,c) + cross(c,a); }

#<b><font color="#5F9EA0">ifdef</font></b> <font color="#B8860B">REMOVE_REDUNDANT</font>
<font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">between</font></b>(<font color="#228B22"><b>const</b></font> PT &amp;a, <font color="#228B22"><b>const</b></font> PT &amp;b, <font color="#228B22"><b>const</b></font> PT &amp;c) {
  <b><font color="#A020F0">return</font></b> (fabs(area2(a,b,c)) &lt; EPS &amp;&amp; (a.x-b.x)*(c.x-b.x) &lt;= 0 &amp;&amp; (a.y-b.y)*(c.y-b.y) &lt;= 0);
}
#<b><font color="#5F9EA0">endif</font></b>

<font color="#228B22"><b>void</b></font> <b><font color="#0000FF">ConvexHull</font></b>(vector&lt;PT&gt; &amp;pts) {
  sort(pts.begin(), pts.end());
  pts.erase(unique(pts.begin(), pts.end()), pts.end());
  vector&lt;PT&gt; up, dn;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; pts.size(); i++) {
    <b><font color="#A020F0">while</font></b> (up.size() &gt; 1 &amp;&amp; area2(up[up.size()-2], up.back(), pts[i]) &gt;= 0) up.pop_back();
    <b><font color="#A020F0">while</font></b> (dn.size() &gt; 1 &amp;&amp; area2(dn[dn.size()-2], dn.back(), pts[i]) &lt;= 0) dn.pop_back();
    up.push_back(pts[i]);
    dn.push_back(pts[i]);
  }
  pts = dn;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = (<font color="#228B22"><b>int</b></font>) up.size() - 2; i &gt;= 1; i--) pts.push_back(up[i]);
  
#<b><font color="#5F9EA0">ifdef</font></b> <font color="#B8860B">REMOVE_REDUNDANT</font>
  <b><font color="#A020F0">if</font></b> (pts.size() &lt;= 2) <b><font color="#A020F0">return</font></b>;
  dn.clear();
  dn.push_back(pts[0]);
  dn.push_back(pts[1]);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 2; i &lt; pts.size(); i++) {
    <b><font color="#A020F0">if</font></b> (between(dn[dn.size()-2], dn[dn.size()-1], pts[i])) dn.pop_back();
    dn.push_back(pts[i]);
  }
  <b><font color="#A020F0">if</font></b> (dn.size() &gt;= 3 &amp;&amp; between(dn.back(), dn[0], dn[1])) {
    dn[0] = dn.back();
    dn.pop_back();
  }
  pts = dn;
#<b><font color="#5F9EA0">endif</font></b>
}

</pre>
<hr>
</a><a name="file8">
<h1>Geometry.cc 8/27</h1>
<pre><i><font color="#B22222">// C++ routines for computational geometry.
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cassert&gt;</b></font>

using namespace std;

<font color="#228B22"><b>double</b></font> INF = 1e100;
<font color="#228B22"><b>double</b></font> EPS = 1e-12;

<font color="#228B22"><b>struct</b></font> PT { 
  <font color="#228B22"><b>double</b></font> x, y; 
  PT() {}
  PT(<font color="#228B22"><b>double</b></font> x, <font color="#228B22"><b>double</b></font> y) : x(x), y(y) {}
  PT(<font color="#228B22"><b>const</b></font> PT &amp;p) : x(p.x), y(p.y)    {}
  PT <b><font color="#A020F0">operator</font></b> + (<font color="#228B22"><b>const</b></font> PT &amp;p)  <font color="#228B22"><b>const</b></font> { <b><font color="#A020F0">return</font></b> PT(x+p.x, y+p.y); }
  PT <b><font color="#A020F0">operator</font></b> - (<font color="#228B22"><b>const</b></font> PT &amp;p)  <font color="#228B22"><b>const</b></font> { <b><font color="#A020F0">return</font></b> PT(x-p.x, y-p.y); }
  PT <b><font color="#A020F0">operator</font></b> * (<font color="#228B22"><b>double</b></font> c)     <font color="#228B22"><b>const</b></font> { <b><font color="#A020F0">return</font></b> PT(x*c,   y*c  ); }
  PT <b><font color="#A020F0">operator</font></b> / (<font color="#228B22"><b>double</b></font> c)     <font color="#228B22"><b>const</b></font> { <b><font color="#A020F0">return</font></b> PT(x/c,   y/c  ); }
};

<font color="#228B22"><b>double</b></font> <b><font color="#0000FF">dot</font></b>(PT p, PT q)     { <b><font color="#A020F0">return</font></b> p.x*q.x+p.y*q.y; }
<font color="#228B22"><b>double</b></font> <b><font color="#0000FF">dist2</font></b>(PT p, PT q)   { <b><font color="#A020F0">return</font></b> dot(p-q,p-q); }
<font color="#228B22"><b>double</b></font> <b><font color="#0000FF">cross</font></b>(PT p, PT q)   { <b><font color="#A020F0">return</font></b> p.x*q.y-p.y*q.x; }
ostream &amp;<b><font color="#A020F0">operator</font></b>&lt;&lt;(ostream &amp;os, <font color="#228B22"><b>const</b></font> PT &amp;p) {
  os &lt;&lt; <font color="#BC8F8F"><b>"("</b></font> &lt;&lt; p.x &lt;&lt; <font color="#BC8F8F"><b>","</b></font> &lt;&lt; p.y &lt;&lt; <font color="#BC8F8F"><b>")"</b></font>; 
}

<i><font color="#B22222">// rotate a point CCW or CW around the origin
</font></i>PT <b><font color="#0000FF">RotateCCW90</font></b>(PT p)   { <b><font color="#A020F0">return</font></b> PT(-p.y,p.x); }
PT <b><font color="#0000FF">RotateCW90</font></b>(PT p)    { <b><font color="#A020F0">return</font></b> PT(p.y,-p.x); }
PT <b><font color="#0000FF">RotateCCW</font></b>(PT p, <font color="#228B22"><b>double</b></font> t) { 
  <b><font color="#A020F0">return</font></b> PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); 
}

<i><font color="#B22222">// project point c onto line through a and b
</font></i><i><font color="#B22222">// assuming a != b
</font></i>PT <b><font color="#0000FF">ProjectPointLine</font></b>(PT a, PT b, PT c) {
  <b><font color="#A020F0">return</font></b> a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
}

<i><font color="#B22222">// project point c onto line segment through a and b
</font></i>PT <b><font color="#0000FF">ProjectPointSegment</font></b>(PT a, PT b, PT c) {
  <font color="#228B22"><b>double</b></font> r = dot(b-a,b-a);
  <b><font color="#A020F0">if</font></b> (fabs(r) &lt; EPS) <b><font color="#A020F0">return</font></b> a;
  r = dot(c-a, b-a)/r;
  <b><font color="#A020F0">if</font></b> (r &lt; 0) <b><font color="#A020F0">return</font></b> a;
  <b><font color="#A020F0">if</font></b> (r &gt; 1) <b><font color="#A020F0">return</font></b> b;
  <b><font color="#A020F0">return</font></b> a + (b-a)*r;
}

<i><font color="#B22222">// compute distance from c to segment between a and b
</font></i><font color="#228B22"><b>double</b></font> <b><font color="#0000FF">DistancePointSegment</font></b>(PT a, PT b, PT c) {
  <b><font color="#A020F0">return</font></b> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}

<i><font color="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</font></i><font color="#228B22"><b>double</b></font> <b><font color="#0000FF">DistancePointPlane</font></b>(<font color="#228B22"><b>double</b></font> x, <font color="#228B22"><b>double</b></font> y, <font color="#228B22"><b>double</b></font> z,
                          <font color="#228B22"><b>double</b></font> a, <font color="#228B22"><b>double</b></font> b, <font color="#228B22"><b>double</b></font> c, <font color="#228B22"><b>double</b></font> d)
{
  <b><font color="#A020F0">return</font></b> fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
}

<i><font color="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">LinesParallel</font></b>(PT a, PT b, PT c, PT d) { 
  <b><font color="#A020F0">return</font></b> fabs(cross(b-a, c-d)) &lt; EPS; 
}

<font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">LinesCollinear</font></b>(PT a, PT b, PT c, PT d) { 
  <b><font color="#A020F0">return</font></b> LinesParallel(a, b, c, d)
      &amp;&amp; fabs(cross(a-b, a-c)) &lt; EPS
      &amp;&amp; fabs(cross(c-d, c-a)) &lt; EPS; 
}

<i><font color="#B22222">// determine if line segment from a to b intersects with 
</font></i><i><font color="#B22222">// line segment from c to d
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">SegmentsIntersect</font></b>(PT a, PT b, PT c, PT d) {
  <b><font color="#A020F0">if</font></b> (LinesCollinear(a, b, c, d)) {
    <b><font color="#A020F0">if</font></b> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
      dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS) <b><font color="#A020F0">return</font></b> true;
    <b><font color="#A020F0">if</font></b> (dot(c-a, c-b) &gt; 0 &amp;&amp; dot(d-a, d-b) &gt; 0 &amp;&amp; dot(c-b, d-b) &gt; 0)
      <b><font color="#A020F0">return</font></b> false;
    <b><font color="#A020F0">return</font></b> true;
  }
  <b><font color="#A020F0">if</font></b> (cross(d-a, b-a) * cross(c-a, b-a) &gt; 0) <b><font color="#A020F0">return</font></b> false;
  <b><font color="#A020F0">if</font></b> (cross(a-c, d-c) * cross(b-c, d-c) &gt; 0) <b><font color="#A020F0">return</font></b> false;
  <b><font color="#A020F0">return</font></b> true;
}

<i><font color="#B22222">// compute intersection of line passing through a and b
</font></i><i><font color="#B22222">// with line passing through c and d, assuming that unique
</font></i><i><font color="#B22222">// intersection exists; for segment intersection, check if
</font></i><i><font color="#B22222">// segments intersect first
</font></i>PT <b><font color="#0000FF">ComputeLineIntersection</font></b>(PT a, PT b, PT c, PT d) {
  b=b-a; d=c-d; c=c-a;
  assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
  <b><font color="#A020F0">return</font></b> a + b*cross(c, d)/cross(b, d);
}

<i><font color="#B22222">// compute center of circle given three points
</font></i>PT <b><font color="#0000FF">ComputeCircleCenter</font></b>(PT a, PT b, PT c) {
  b=(a+b)/2;
  c=(a+c)/2;
  <b><font color="#A020F0">return</font></b> ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
}

<i><font color="#B22222">// determine if point is in a possibly non-convex polygon (by William
</font></i><i><font color="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</font></i><i><font color="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</font></i><i><font color="#B22222">// Note that it is possible to convert this into an *exact* test using
</font></i><i><font color="#B22222">// integer arithmetic by taking care of the division appropriately
</font></i><i><font color="#B22222">// (making sure to deal with signs properly) and then by writing exact
</font></i><i><font color="#B22222">// tests for checking point on polygon boundary
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">PointInPolygon</font></b>(<font color="#228B22"><b>const</b></font> vector&lt;PT&gt; &amp;p, PT q) {
  <font color="#228B22"><b>bool</b></font> c = 0;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; p.size(); i++){
    <font color="#228B22"><b>int</b></font> j = (i+1)%p.size();
    <b><font color="#A020F0">if</font></b> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y || 
      p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;
      q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
      c = !c;
  }
  <b><font color="#A020F0">return</font></b> c;
}

<i><font color="#B22222">// determine if point is on the boundary of a polygon
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">PointOnPolygon</font></b>(<font color="#228B22"><b>const</b></font> vector&lt;PT&gt; &amp;p, PT q) {
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; p.size(); i++)
    <b><font color="#A020F0">if</font></b> (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) &lt; EPS)
      <b><font color="#A020F0">return</font></b> true;
    <b><font color="#A020F0">return</font></b> false;
}

<i><font color="#B22222">// compute intersection of line through points a and b with
</font></i><i><font color="#B22222">// circle centered at c with radius r &gt; 0
</font></i>vector&lt;PT&gt; CircleLineIntersection(PT a, PT b, PT c, <font color="#228B22"><b>double</b></font> r) {
  vector&lt;PT&gt; ret;
  b = b-a;
  a = a-c;
  <font color="#228B22"><b>double</b></font> A = dot(b, b);
  <font color="#228B22"><b>double</b></font> B = dot(a, b);
  <font color="#228B22"><b>double</b></font> C = dot(a, a) - r*r;
  <font color="#228B22"><b>double</b></font> D = B*B - A*C;
  <b><font color="#A020F0">if</font></b> (D &lt; -EPS) <b><font color="#A020F0">return</font></b> ret;
  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
  <b><font color="#A020F0">if</font></b> (D &gt; EPS)
    ret.push_back(c+a+b*(-B-sqrt(D))/A);
  <b><font color="#A020F0">return</font></b> ret;
}

<i><font color="#B22222">// compute intersection of circle centered at a with radius r
</font></i><i><font color="#B22222">// with circle centered at b with radius R
</font></i>vector&lt;PT&gt; CircleCircleIntersection(PT a, PT b, <font color="#228B22"><b>double</b></font> r, <font color="#228B22"><b>double</b></font> R) {
  vector&lt;PT&gt; ret;
  <font color="#228B22"><b>double</b></font> d = sqrt(dist2(a, b));
  <b><font color="#A020F0">if</font></b> (d &gt; r+R || d+min(r, R) &lt; max(r, R)) <b><font color="#A020F0">return</font></b> ret;
  <font color="#228B22"><b>double</b></font> x = (d*d-R*R+r*r)/(2*d);
  <font color="#228B22"><b>double</b></font> y = sqrt(r*r-x*x);
  PT v = (b-a)/d;
  ret.push_back(a+v*x + RotateCCW90(v)*y);
  <b><font color="#A020F0">if</font></b> (y &gt; 0)
    ret.push_back(a+v*x - RotateCCW90(v)*y);
  <b><font color="#A020F0">return</font></b> ret;
}

<i><font color="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</font></i><i><font color="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</font></i><i><font color="#B22222">// counterclockwise fashion.  Note that the centroid is often known as
</font></i><i><font color="#B22222">// the "center of gravity" or "center of mass".
</font></i><font color="#228B22"><b>double</b></font> <b><font color="#0000FF">ComputeSignedArea</font></b>(<font color="#228B22"><b>const</b></font> vector&lt;PT&gt; &amp;p) {
  <font color="#228B22"><b>double</b></font> area = 0;
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0; i &lt; p.size(); i++) {
    <font color="#228B22"><b>int</b></font> j = (i+1) % p.size();
    area += p[i].x*p[j].y - p[j].x*p[i].y;
  }
  <b><font color="#A020F0">return</font></b> area / 2.0;
}

<font color="#228B22"><b>double</b></font> <b><font color="#0000FF">ComputeArea</font></b>(<font color="#228B22"><b>const</b></font> vector&lt;PT&gt; &amp;p) {
  <b><font color="#A020F0">return</font></b> fabs(ComputeSignedArea(p));
}

PT <b><font color="#0000FF">ComputeCentroid</font></b>(<font color="#228B22"><b>const</b></font> vector&lt;PT&gt; &amp;p) {
  PT c(0,0);
  <font color="#228B22"><b>double</b></font> scale = 6.0 * ComputeSignedArea(p);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; p.size(); i++){
    <font color="#228B22"><b>int</b></font> j = (i+1) % p.size();
    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
  }
  <b><font color="#A020F0">return</font></b> c / scale;
}

<i><font color="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">IsSimple</font></b>(<font color="#228B22"><b>const</b></font> vector&lt;PT&gt; &amp;p) {
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; p.size(); i++) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = i+1; k &lt; p.size(); k++) {
      <font color="#228B22"><b>int</b></font> j = (i+1) % p.size();
      <font color="#228B22"><b>int</b></font> l = (k+1) % p.size();
      <b><font color="#A020F0">if</font></b> (i == l || j == k) <b><font color="#A020F0">continue</font></b>;
      <b><font color="#A020F0">if</font></b> (SegmentsIntersect(p[i], p[j], p[k], p[l])) 
        <b><font color="#A020F0">return</font></b> false;
    }
  }
  <b><font color="#A020F0">return</font></b> true;
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>() {
  
  <i><font color="#B22222">// expected: (-5,2)
</font></i>  cerr &lt;&lt; RotateCCW90(PT(2,5)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (5,-2)
</font></i>  cerr &lt;&lt; RotateCW90(PT(2,5)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (-5,2)
</font></i>  cerr &lt;&lt; RotateCCW(PT(2,5),M_PI/2) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (5,2)
</font></i>  cerr &lt;&lt; ProjectPointLine(PT(-5,-2), PT(10,4), PT(3,7)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (5,2) (7.5,3) (2.5,1)
</font></i>  cerr &lt;&lt; ProjectPointSegment(PT(-5,-2), PT(10,4), PT(3,7)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; ProjectPointSegment(PT(7.5,3), PT(10,4), PT(3,7)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; ProjectPointSegment(PT(-5,-2), PT(2.5,1), PT(3,7)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 6.78903
</font></i>  cerr &lt;&lt; DistancePointPlane(4,-4,3,2,-2,5,-8) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 1 0 1
</font></i>  cerr &lt;&lt; LinesParallel(PT(1,1), PT(3,5), PT(2,1), PT(4,5)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; LinesParallel(PT(1,1), PT(3,5), PT(2,0), PT(4,5)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; LinesParallel(PT(1,1), PT(3,5), PT(5,9), PT(7,13)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 0 0 1
</font></i>  cerr &lt;&lt; LinesCollinear(PT(1,1), PT(3,5), PT(2,1), PT(4,5)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; LinesCollinear(PT(1,1), PT(3,5), PT(2,0), PT(4,5)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; LinesCollinear(PT(1,1), PT(3,5), PT(5,9), PT(7,13)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 1 1 1 0
</font></i>  cerr &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(3,1), PT(-1,3)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(4,3), PT(0,5)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(2,-1), PT(-2,1)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(5,5), PT(1,7)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (1,2)
</font></i>  cerr &lt;&lt; ComputeLineIntersection(PT(0,0), PT(2,4), PT(3,1), PT(-1,3)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (1,1)
</font></i>  cerr &lt;&lt; ComputeCircleCenter(PT(-3,4), PT(6,1), PT(4,5)) &lt;&lt; endl;
  
  vector&lt;PT&gt; v; 
  v.push_back(PT(0,0));
  v.push_back(PT(5,0));
  v.push_back(PT(5,5));
  v.push_back(PT(0,5));
  
  <i><font color="#B22222">// expected: 1 1 1 0 0
</font></i>  cerr &lt;&lt; PointInPolygon(v, PT(2,2)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointInPolygon(v, PT(2,0)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointInPolygon(v, PT(0,2)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointInPolygon(v, PT(5,2)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointInPolygon(v, PT(2,5)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 0 1 1 1 1
</font></i>  cerr &lt;&lt; PointOnPolygon(v, PT(2,2)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointOnPolygon(v, PT(2,0)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointOnPolygon(v, PT(0,2)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointOnPolygon(v, PT(5,2)) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>
       &lt;&lt; PointOnPolygon(v, PT(2,5)) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: (1,6)
</font></i>  <i><font color="#B22222">//           (5,4) (4,5)
</font></i>  <i><font color="#B22222">//           blank line
</font></i>  <i><font color="#B22222">//           (4,5) (5,4)
</font></i>  <i><font color="#B22222">//           blank line
</font></i>  <i><font color="#B22222">//           (4,5) (5,4)
</font></i>  vector&lt;PT&gt; u = CircleLineIntersection(PT(0,6), PT(2,6), PT(1,1), 5);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; cerr &lt;&lt; endl;
  u = CircleLineIntersection(PT(0,9), PT(9,0), PT(1,1), 5);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(10,10), 5, 5);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(8,8), 5, 5);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(4.5,4.5), 10, sqrt(2.0)/2.0);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(4.5,4.5), 5, sqrt(2.0)/2.0);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; cerr &lt;&lt; endl;
  
  <i><font color="#B22222">// area should be 5.0
</font></i>  <i><font color="#B22222">// centroid should be (1.1666666, 1.166666)
</font></i>  PT pa[] = { PT(0,0), PT(5,0), PT(1,1), PT(0,5) };
  vector&lt;PT&gt; p(pa, pa+4);
  PT c = ComputeCentroid(p);
  cerr &lt;&lt; <font color="#BC8F8F"><b>"Area: "</b></font> &lt;&lt; ComputeArea(p) &lt;&lt; endl;
  cerr &lt;&lt; <font color="#BC8F8F"><b>"Centroid: "</b></font> &lt;&lt; c &lt;&lt; endl;
  
  <b><font color="#A020F0">return</font></b> 0;
}
</pre>
<hr>
</a><a name="file9">
<h1>JavaGeometry.java 9/27</h1>
<pre><i><font color="#B22222">// In this example, we read an input file containing three lines, each
</font></i><i><font color="#B22222">// containing an even number of doubles, separated by commas.  The first two
</font></i><i><font color="#B22222">// lines represent the coordinates of two polygons, given in counterclockwise 
</font></i><i><font color="#B22222">// (or clockwise) order, which we will call "A" and "B".  The last line 
</font></i><i><font color="#B22222">// contains a list of points, p[1], p[2], ...
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Our goal is to determine:
</font></i><i><font color="#B22222">//   (1) whether B - A is a single closed shape (as opposed to multiple shapes)
</font></i><i><font color="#B22222">//   (2) the area of B - A
</font></i><i><font color="#B22222">//   (3) whether each p[i] is in the interior of B - A
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT:
</font></i><i><font color="#B22222">//   0 0 10 0 0 10
</font></i><i><font color="#B22222">//   0 0 10 10 10 0
</font></i><i><font color="#B22222">//   8 6
</font></i><i><font color="#B22222">//   5 1
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:
</font></i><i><font color="#B22222">//   The area is singular.
</font></i><i><font color="#B22222">//   The area is 25.0
</font></i><i><font color="#B22222">//   Point belongs to the area.
</font></i><i><font color="#B22222">//   Point does not belong to the area.
</font></i>
<b><font color="#A020F0">import</font></b> java.util.*;
<b><font color="#A020F0">import</font></b> java.awt.geom.*;
<b><font color="#A020F0">import</font></b> java.io.*;

<b><font color="#A020F0">public</font></b> <b><font color="#A020F0">class</font></b> JavaGeometry {

    <i><font color="#B22222">// make an array of doubles from a string
</font></i>    <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b>[] readPoints(String s) {
        String[] arr = s.trim().split(<font color="#BC8F8F"><b>"\\s++"</b></font>);
        <b><font color="#A020F0">double</font></b>[] ret = <b><font color="#A020F0">new</font></b> <b><font color="#A020F0">double</font></b>[arr.length];
        <b><font color="#A020F0">for</font></b> (<b><font color="#A020F0">int</font></b> i = 0; i &lt; arr.length; i++) ret[i] = Double.parseDouble(arr[i]);
        <b><font color="#A020F0">return</font></b> ret;
    }

    <i><font color="#B22222">// make an Area object from the coordinates of a polygon
</font></i>    <b><font color="#A020F0">static</font></b> Area makeArea(<b><font color="#A020F0">double</font></b>[] pts) {
        Path2D.Double p = <b><font color="#A020F0">new</font></b> Path2D.Double();
        p.moveTo(pts[0], pts[1]);
        <b><font color="#A020F0">for</font></b> (<b><font color="#A020F0">int</font></b> i = 2; i &lt; pts.length; i += 2) p.lineTo(pts[i], pts[i+1]);
        p.closePath();
        <b><font color="#A020F0">return</font></b> <b><font color="#A020F0">new</font></b> Area(p);        
    }

    <i><font color="#B22222">// compute area of polygon
</font></i>    <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b> computePolygonArea(ArrayList&lt;Point2D.Double&gt; points) {
        Point2D.Double[] pts = points.toArray(<b><font color="#A020F0">new</font></b> Point2D.Double[points.size()]);  
        <b><font color="#A020F0">double</font></b> area = 0;
        <b><font color="#A020F0">for</font></b> (<b><font color="#A020F0">int</font></b> i = 0; i &lt; pts.length; i++){
            <b><font color="#A020F0">int</font></b> j = (i+1) % pts.length;
            area += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
        }        
        <b><font color="#A020F0">return</font></b> Math.abs(area)/2;
    }

    <i><font color="#B22222">// compute the area of an Area object containing several disjoint polygons
</font></i>    <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b> computeArea(Area area) {
        <b><font color="#A020F0">double</font></b> totArea = 0;
        PathIterator iter = area.getPathIterator(<b><font color="#A020F0">null</font></b>);
        ArrayList&lt;Point2D.Double&gt; points = <b><font color="#A020F0">new</font></b> ArrayList&lt;Point2D.Double&gt;();

        <b><font color="#A020F0">while</font></b> (!iter.isDone()) {
            <b><font color="#A020F0">double</font></b>[] buffer = <b><font color="#A020F0">new</font></b> <b><font color="#A020F0">double</font></b>[6];
            <b><font color="#A020F0">switch</font></b> (iter.currentSegment(buffer)) {
            <b><font color="#A020F0">case</font></b> PathIterator.SEG_MOVETO:
            <b><font color="#A020F0">case</font></b> PathIterator.SEG_LINETO:
                points.add(<b><font color="#A020F0">new</font></b> Point2D.Double(buffer[0], buffer[1]));
                <b><font color="#A020F0">break</font></b>;
            <b><font color="#A020F0">case</font></b> PathIterator.SEG_CLOSE:
                totArea += computePolygonArea(points);
                points.clear();
                <b><font color="#A020F0">break</font></b>;
            }
            iter.next();
        }
        <b><font color="#A020F0">return</font></b> totArea;
    }

    <i><font color="#B22222">// notice that the main() throws an Exception -- necessary to
</font></i>    <i><font color="#B22222">// avoid wrapping the Scanner object for file reading in a 
</font></i>    <i><font color="#B22222">// try { ... } catch block.
</font></i>    <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">void</font></b> main(String args[]) <b><font color="#A020F0">throws</font></b> Exception {

        Scanner scanner = <b><font color="#A020F0">new</font></b> Scanner(<b><font color="#A020F0">new</font></b> File(<font color="#BC8F8F"><b>"input.txt"</b></font>));
        <i><font color="#B22222">// also,
</font></i>        <i><font color="#B22222">//   Scanner scanner = new Scanner (System.in);
</font></i>
        <b><font color="#A020F0">double</font></b>[] pointsA = readPoints(scanner.nextLine());
        <b><font color="#A020F0">double</font></b>[] pointsB = readPoints(scanner.nextLine());
        Area areaA = makeArea(pointsA);
        Area areaB = makeArea(pointsB);
        areaB.subtract(areaA);
        <i><font color="#B22222">// also,
</font></i>        <i><font color="#B22222">//   areaB.exclusiveOr (areaA);
</font></i>        <i><font color="#B22222">//   areaB.add (areaA);
</font></i>        <i><font color="#B22222">//   areaB.intersect (areaA);
</font></i>        
        <i><font color="#B22222">// (1) determine whether B - A is a single closed shape (as 
</font></i>        <i><font color="#B22222">//     opposed to multiple shapes)
</font></i>        <b><font color="#A020F0">boolean</font></b> isSingle = areaB.isSingular();
        <i><font color="#B22222">// also,
</font></i>        <i><font color="#B22222">//   areaB.isEmpty();
</font></i>
        <b><font color="#A020F0">if</font></b> (isSingle)
            System.out.println(<font color="#BC8F8F"><b>"The area is singular."</b></font>);
        <b><font color="#A020F0">else</font></b>
            System.out.println(<font color="#BC8F8F"><b>"The area is not singular."</b></font>);
        
        <i><font color="#B22222">// (2) compute the area of B - A
</font></i>        System.out.println(<font color="#BC8F8F"><b>"The area is "</b></font> + computeArea(areaB) + <font color="#BC8F8F"><b>"."</b></font>);
        
        <i><font color="#B22222">// (3) determine whether each p[i] is in the interior of B - A
</font></i>        <b><font color="#A020F0">while</font></b> (scanner.hasNextDouble()) {
            <b><font color="#A020F0">double</font></b> x = scanner.nextDouble();
            assert(scanner.hasNextDouble());
            <b><font color="#A020F0">double</font></b> y = scanner.nextDouble();

            <b><font color="#A020F0">if</font></b> (areaB.contains(x,y)) {
                System.out.println (<font color="#BC8F8F"><b>"Point belongs to the area."</b></font>);
            } <b><font color="#A020F0">else</font></b> {
                System.out.println (<font color="#BC8F8F"><b>"Point does not belong to the area."</b></font>);
            }
        }

        <i><font color="#B22222">// Finally, some useful things we didn't use in this example:
</font></i>        <i><font color="#B22222">//
</font></i>        <i><font color="#B22222">//   Ellipse2D.Double ellipse = new Ellipse2D.Double (double x, double y, 
</font></i>        <i><font color="#B22222">//                                                    double w, double h);
</font></i>        <i><font color="#B22222">//
</font></i>        <i><font color="#B22222">//     creates an ellipse inscribed in box with bottom-left corner (x,y)
</font></i>        <i><font color="#B22222">//     and upper-right corner (x+y,w+h)
</font></i>        <i><font color="#B22222">// 
</font></i>        <i><font color="#B22222">//   Rectangle2D.Double rect = new Rectangle2D.Double (double x, double y, 
</font></i>        <i><font color="#B22222">//                                                     double w, double h);
</font></i>        <i><font color="#B22222">//
</font></i>        <i><font color="#B22222">//     creates a box with bottom-left corner (x,y) and upper-right 
</font></i>        <i><font color="#B22222">//     corner (x+y,w+h)
</font></i>        <i><font color="#B22222">//
</font></i>        <i><font color="#B22222">// Each of these can be embedded in an Area object (e.g., new Area (rect)).
</font></i>
    }
}
</pre>
<hr>
</a><a name="file10">
<h1>Geom3D.java 10/27</h1>
<pre><b><font color="#A020F0">public</font></b> <b><font color="#A020F0">class</font></b> Geom3D {
  <i><font color="#B22222">// distance from point (x, y, z) to plane aX + bY + cZ + d = 0
</font></i>  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b> ptPlaneDist(<b><font color="#A020F0">double</font></b> x, <b><font color="#A020F0">double</font></b> y, <b><font color="#A020F0">double</font></b> z,
      <b><font color="#A020F0">double</font></b> a, <b><font color="#A020F0">double</font></b> b, <b><font color="#A020F0">double</font></b> c, <b><font color="#A020F0">double</font></b> d) {
    <b><font color="#A020F0">return</font></b> Math.abs(a*x + b*y + c*z + d) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <i><font color="#B22222">// distance between parallel planes aX + bY + cZ + d1 = 0 and
</font></i>  <i><font color="#B22222">// aX + bY + cZ + d2 = 0
</font></i>  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b> planePlaneDist(<b><font color="#A020F0">double</font></b> a, <b><font color="#A020F0">double</font></b> b, <b><font color="#A020F0">double</font></b> c,
      <b><font color="#A020F0">double</font></b> d1, <b><font color="#A020F0">double</font></b> d2) {
    <b><font color="#A020F0">return</font></b> Math.abs(d1 - d2) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <i><font color="#B22222">// distance from point (px, py, pz) to line (x1, y1, z1)-(x2, y2, z2)
</font></i>  <i><font color="#B22222">// (or ray, or segment; in the case of the ray, the endpoint is the
</font></i>  <i><font color="#B22222">// first point)
</font></i>  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">final</font></b> <b><font color="#A020F0">int</font></b> LINE = 0;
  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">final</font></b> <b><font color="#A020F0">int</font></b> SEGMENT = 1;
  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">final</font></b> <b><font color="#A020F0">int</font></b> RAY = 2;
  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b> ptLineDistSq(<b><font color="#A020F0">double</font></b> x1, <b><font color="#A020F0">double</font></b> y1, <b><font color="#A020F0">double</font></b> z1,
      <b><font color="#A020F0">double</font></b> x2, <b><font color="#A020F0">double</font></b> y2, <b><font color="#A020F0">double</font></b> z2, <b><font color="#A020F0">double</font></b> px, <b><font color="#A020F0">double</font></b> py, <b><font color="#A020F0">double</font></b> pz,
      <b><font color="#A020F0">int</font></b> type) {
    <b><font color="#A020F0">double</font></b> pd2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2);
    
    <b><font color="#A020F0">double</font></b> x, y, z;
    <b><font color="#A020F0">if</font></b> (pd2 == 0) {
      x = x1;
      y = y1;
      z = z1;
    } <b><font color="#A020F0">else</font></b> {
      <b><font color="#A020F0">double</font></b> u = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1) + (pz-z1)*(z2-z1)) / pd2;
      x = x1 + u * (x2 - x1);
      y = y1 + u * (y2 - y1);
      z = z1 + u * (z2 - z1);
      <b><font color="#A020F0">if</font></b> (type != LINE &amp;&amp; u &lt; 0) {
        x = x1;
        y = y1;
        z = z1;
      }
      <b><font color="#A020F0">if</font></b> (type == SEGMENT &amp;&amp; u &gt; 1.0) {
        x = x2;
        y = y2;
        z = z2;
      }
    }
    
    <b><font color="#A020F0">return</font></b> (x-px)*(x-px) + (y-py)*(y-py) + (z-pz)*(z-pz);
  }
  
  <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">double</font></b> ptLineDist(<b><font color="#A020F0">double</font></b> x1, <b><font color="#A020F0">double</font></b> y1, <b><font color="#A020F0">double</font></b> z1,
      <b><font color="#A020F0">double</font></b> x2, <b><font color="#A020F0">double</font></b> y2, <b><font color="#A020F0">double</font></b> z2, <b><font color="#A020F0">double</font></b> px, <b><font color="#A020F0">double</font></b> py, <b><font color="#A020F0">double</font></b> pz,
      <b><font color="#A020F0">int</font></b> type) {
    <b><font color="#A020F0">return</font></b> Math.sqrt(ptLineDistSq(x1, y1, z1, x2, y2, z2, px, py, pz, type));
  }
}
</pre>
<hr>
</a><a name="file11">
<h1>Delaunay.cc 11/27</h1>
<pre><i><font color="#B22222">// Slow but simple Delaunay triangulation. Does not handle
</font></i><i><font color="#B22222">// degenerate cases (from O'Rourke, Computational Geometry in C)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(n^4)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT:    x[] = x-coordinates
</font></i><i><font color="#B22222">//           y[] = y-coordinates
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:   triples = a vector containing m triples of indices
</font></i><i><font color="#B22222">//                     corresponding to triangle vertices
</font></i>
#<b><font color="#5F9EA0">include&lt;vector&gt;</font></b>
using namespace std;

<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>double</b></font> T;

<font color="#228B22"><b>struct</b></font> triple {
    <font color="#228B22"><b>int</b></font> i, j, k;
    triple() {}
    triple(<font color="#228B22"><b>int</b></font> i, <font color="#228B22"><b>int</b></font> j, <font color="#228B22"><b>int</b></font> k) : i(i), j(j), k(k) {}
};

vector&lt;triple&gt; delaunayTriangulation(vector&lt;T&gt;&amp; x, vector&lt;T&gt;&amp; y) {
	<font color="#228B22"><b>int</b></font> n = x.size();
	vector&lt;T&gt; z(n);
	vector&lt;triple&gt; ret;

	<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++)
	    z[i] = x[i] * x[i] + y[i] * y[i];

	<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n-2; i++) {
	    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = i+1; j &lt; n; j++) {
		<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = i+1; k &lt; n; k++) {
		    <b><font color="#A020F0">if</font></b> (j == k) <b><font color="#A020F0">continue</font></b>;
		    <font color="#228B22"><b>double</b></font> xn = (y[j]-y[i])*(z[k]-z[i]) - (y[k]-y[i])*(z[j]-z[i]);
		    <font color="#228B22"><b>double</b></font> yn = (x[k]-x[i])*(z[j]-z[i]) - (x[j]-x[i])*(z[k]-z[i]);
		    <font color="#228B22"><b>double</b></font> zn = (x[j]-x[i])*(y[k]-y[i]) - (x[k]-x[i])*(y[j]-y[i]);
		    <font color="#228B22"><b>bool</b></font> flag = zn &lt; 0;
		    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> m = 0; flag &amp;&amp; m &lt; n; m++)
			flag = flag &amp;&amp; ((x[m]-x[i])*xn + 
					(y[m]-y[i])*yn + 
					(z[m]-z[i])*zn &lt;= 0);
		    <b><font color="#A020F0">if</font></b> (flag) ret.push_back(triple(i, j, k));
		}
	    }
	}
	<b><font color="#A020F0">return</font></b> ret;
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>()
{
    T xs[]={0, 0, 1, 0.9};
    T ys[]={0, 1, 0, 0.9};
    vector&lt;T&gt; x(&amp;xs[0], &amp;xs[4]), y(&amp;ys[0], &amp;ys[4]);
    vector&lt;triple&gt; tri = delaunayTriangulation(x, y);
    
    <i><font color="#B22222">//expected: 0 1 3
</font></i>    <i><font color="#B22222">//          0 3 2
</font></i>    
    <font color="#228B22"><b>int</b></font> i;
    <b><font color="#A020F0">for</font></b>(i = 0; i &lt; tri.size(); i++)
        printf(<font color="#BC8F8F"><b>"%d %d %d\n"</b></font>, tri[i].i, tri[i].j, tri[i].k);
    <b><font color="#A020F0">return</font></b> 0;
}
</pre>
<hr>
</a><a name="file12">
<h1>Euclid.cc 12/27</h1>
<pre><i><font color="#B22222">// This is a collection of useful code for solving problems that
</font></i><i><font color="#B22222">// involve modular linear equations.  Note that all of the
</font></i><i><font color="#B22222">// algorithms described here work on nonnegative integers.
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;algorithm&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;
<font color="#228B22"><b>typedef</b></font> pair&lt;<font color="#228B22"><b>int</b></font>,<font color="#228B22"><b>int</b></font>&gt; PII;

<i><font color="#B22222">// return a % b (positive value)
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">mod</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> b) {
  <b><font color="#A020F0">return</font></b> ((a%b)+b)%b;
}

<i><font color="#B22222">// computes gcd(a,b)
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">gcd</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> b) {
  <font color="#228B22"><b>int</b></font> tmp;
  <b><font color="#A020F0">while</font></b>(b){a%=b; tmp=a; a=b; b=tmp;}
  <b><font color="#A020F0">return</font></b> a;
}

<i><font color="#B22222">// computes lcm(a,b)
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">lcm</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> b) {
  <b><font color="#A020F0">return</font></b> a/gcd(a,b)*b;
}

<i><font color="#B22222">// returns d = gcd(a,b); finds x,y such that d = ax + by
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">extended_euclid</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> b, <font color="#228B22"><b>int</b></font> &amp;x, <font color="#228B22"><b>int</b></font> &amp;y) {  
  <font color="#228B22"><b>int</b></font> xx = y = 0;
  <font color="#228B22"><b>int</b></font> yy = x = 1;
  <b><font color="#A020F0">while</font></b> (b) {
    <font color="#228B22"><b>int</b></font> q = a/b;
    <font color="#228B22"><b>int</b></font> t = b; b = a%b; a = t;
    t = xx; xx = x-q*xx; x = t;
    t = yy; yy = y-q*yy; y = t;
  }
  <b><font color="#A020F0">return</font></b> a;
}

<i><font color="#B22222">// finds all solutions to ax = b (mod n)
</font></i>VI <b><font color="#0000FF">modular_linear_equation_solver</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> b, <font color="#228B22"><b>int</b></font> n) {
  <font color="#228B22"><b>int</b></font> x, y;
  VI solutions;
  <font color="#228B22"><b>int</b></font> d = extended_euclid(a, n, x, y);
  <b><font color="#A020F0">if</font></b> (!(b%d)) {
    x = mod (x*(b/d), n);
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; d; i++)
      solutions.push_back(mod(x + i*(n/d), n));
  }
  <b><font color="#A020F0">return</font></b> solutions;
}

<i><font color="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">mod_inverse</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> n) {
  <font color="#228B22"><b>int</b></font> x, y;
  <font color="#228B22"><b>int</b></font> d = extended_euclid(a, n, x, y);
  <b><font color="#A020F0">if</font></b> (d &gt; 1) <b><font color="#A020F0">return</font></b> -1;
  <b><font color="#A020F0">return</font></b> mod(x,n);
}

<i><font color="#B22222">// Chinese remainder theorem (special case): find z such that
</font></i><i><font color="#B22222">// z % x = a, z % y = b.  Here, z is unique modulo M = lcm(x,y).
</font></i><i><font color="#B22222">// Return (z,M).  On failure, M = -1.
</font></i>PII <b><font color="#0000FF">chinese_remainder_theorem</font></b>(<font color="#228B22"><b>int</b></font> x, <font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> y, <font color="#228B22"><b>int</b></font> b) {
  <font color="#228B22"><b>int</b></font> s, t;
  <font color="#228B22"><b>int</b></font> d = extended_euclid(x, y, s, t);
  <b><font color="#A020F0">if</font></b> (a%d != b%d) <b><font color="#A020F0">return</font></b> make_pair(0, -1);
  <b><font color="#A020F0">return</font></b> make_pair(mod(s*b*x+t*a*y,x*y)/d, x*y/d);
}

<i><font color="#B22222">// Chinese remainder theorem: find z such that
</font></i><i><font color="#B22222">// z % x[i] = a[i] for all i.  Note that the solution is
</font></i><i><font color="#B22222">// unique modulo M = lcm_i (x[i]).  Return (z,M).  On 
</font></i><i><font color="#B22222">// failure, M = -1.  Note that we do not require the a[i]'s
</font></i><i><font color="#B22222">// to be relatively prime.
</font></i>PII <b><font color="#0000FF">chinese_remainder_theorem</font></b>(<font color="#228B22"><b>const</b></font> VI &amp;x, <font color="#228B22"><b>const</b></font> VI &amp;a) {
  PII ret = make_pair(a[0], x[0]);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 1; i &lt; x.size(); i++) {
    ret = chinese_remainder_theorem(ret.second, ret.first, x[i], a[i]);
    <b><font color="#A020F0">if</font></b> (ret.second == -1) <b><font color="#A020F0">break</font></b>;
  }
  <b><font color="#A020F0">return</font></b> ret;
}

<i><font color="#B22222">// computes x and y such that ax + by = c; on failure, x = y =-1
</font></i><font color="#228B22"><b>void</b></font> <b><font color="#0000FF">linear_diophantine</font></b>(<font color="#228B22"><b>int</b></font> a, <font color="#228B22"><b>int</b></font> b, <font color="#228B22"><b>int</b></font> c, <font color="#228B22"><b>int</b></font> &amp;x, <font color="#228B22"><b>int</b></font> &amp;y) {
  <font color="#228B22"><b>int</b></font> d = gcd(a,b);
  <b><font color="#A020F0">if</font></b> (c%d) {
    x = y = -1;
  } <b><font color="#A020F0">else</font></b> {
    x = c/d * mod_inverse(a/d, b/d);
    y = (c-a*x)/b;
  }
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>() {
  
  <i><font color="#B22222">// expected: 2
</font></i>  cout &lt;&lt; gcd(14, 30) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 2 -2 1
</font></i>  <font color="#228B22"><b>int</b></font> x, y;
  <font color="#228B22"><b>int</b></font> d = extended_euclid(14, 30, x, y);
  cout &lt;&lt; d &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; x &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; y &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 95 45
</font></i>  VI sols = modular_linear_equation_solver(14, 30, 100);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; (<font color="#228B22"><b>int</b></font>) sols.size(); i++) cout &lt;&lt; sols[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>; 
  cout &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 8
</font></i>  cout &lt;&lt; mod_inverse(8, 9) &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 23 56
</font></i>  <i><font color="#B22222">//           11 12
</font></i>  <font color="#228B22"><b>int</b></font> xs[] = {3, 5, 7, 4, 6};
  <font color="#228B22"><b>int</b></font> as[] = {2, 3, 2, 3, 5};
  PII ret = chinese_remainder_theorem(VI (xs, xs+3), VI(as, as+3));
  cout &lt;&lt; ret.first &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; ret.second &lt;&lt; endl;
  ret = chinese_remainder_theorem (VI(xs+3, xs+5), VI(as+3, as+5));
  cout &lt;&lt; ret.first &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; ret.second &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 5 -15
</font></i>  linear_diophantine(7, 2, 5, x, y);
  cout &lt;&lt; x &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; y &lt;&lt; endl;

}
</pre>
<hr>
</a><a name="file13">
<h1>GaussJordan.cc 13/27</h1>
<pre><i><font color="#B22222">// Gauss-Jordan elimination with full pivoting.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Uses:
</font></i><i><font color="#B22222">//   (1) solving systems of linear equations (AX=B)
</font></i><i><font color="#B22222">//   (2) inverting matrices (AX=I)
</font></i><i><font color="#B22222">//   (3) computing determinants of square matrices
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(n^3)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT:    a[][] = an nxn matrix
</font></i><i><font color="#B22222">//           b[][] = an nxm matrix
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</font></i><i><font color="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</font></i><i><font color="#B22222">//           returns determinant of a[][]
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>

using namespace std;

<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>double</b></font> EPS = 1e-10;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;
<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>double</b></font> T;
<font color="#228B22"><b>typedef</b></font> vector&lt;T&gt; VT;
<font color="#228B22"><b>typedef</b></font> vector&lt;VT&gt; VVT;

T GaussJordan(VVT &amp;a, VVT &amp;b) {
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> n = a.size();
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> m = b[0].size();
  VI irow(n), icol(n), ipiv(n);
  T det = 1;

  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) {
    <font color="#228B22"><b>int</b></font> pj = -1, pk = -1;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n; j++) <b><font color="#A020F0">if</font></b> (!ipiv[j])
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; n; k++) <b><font color="#A020F0">if</font></b> (!ipiv[k])
	<b><font color="#A020F0">if</font></b> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) { pj = j; pk = k; }
    <b><font color="#A020F0">if</font></b> (fabs(a[pj][pk]) &lt; EPS) { cerr &lt;&lt; <font color="#BC8F8F"><b>"Matrix is singular."</b></font> &lt;&lt; endl; exit(0); }
    ipiv[pk]++;
    swap(a[pj], a[pk]);
    swap(b[pj], b[pk]);
    <b><font color="#A020F0">if</font></b> (pj != pk) det *= -1;
    irow[i] = pj;
    icol[i] = pk;

    T c = 1.0 / a[pk][pk];
    det *= a[pk][pk];
    a[pk][pk] = 1.0;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> p = 0; p &lt; n; p++) a[pk][p] *= c;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> p = 0; p &lt; m; p++) b[pk][p] *= c;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> p = 0; p &lt; n; p++) <b><font color="#A020F0">if</font></b> (p != pk) {
      c = a[p][pk];
      a[p][pk] = 0;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;      
    }
  }

  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> p = n-1; p &gt;= 0; p--) <b><font color="#A020F0">if</font></b> (irow[p] != icol[p]) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = 0; k &lt; n; k++) swap(a[k][irow[p]], a[k][icol[p]]);
  }

  <b><font color="#A020F0">return</font></b> det;
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>() {
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> n = 4;
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> m = 2;
  <font color="#228B22"><b>double</b></font> A[n][n] = { {1,2,3,4},{1,0,1,0},{5,3,2,4},{6,1,4,6} };
  <font color="#228B22"><b>double</b></font> B[n][m] = { {1,2},{4,3},{5,6},{8,7} };
  VVT a(n), b(n);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) {
    a[i] = VT(A[i], A[i] + n);
    b[i] = VT(B[i], B[i] + m);
  }
  
  <font color="#228B22"><b>double</b></font> det = GaussJordan(a, b);
  
  <i><font color="#B22222">// expected: 60  
</font></i>  cout &lt;&lt; <font color="#BC8F8F"><b>"Determinant: "</b></font> &lt;&lt; det &lt;&lt; endl;

  <i><font color="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</font></i>  <i><font color="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</font></i>  <i><font color="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</font></i>  <i><font color="#B22222">//           0.05 -0.75 -0.1 0.2
</font></i>  cout &lt;&lt; <font color="#BC8F8F"><b>"Inverse: "</b></font> &lt;&lt; endl;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n; j++)
      cout &lt;&lt; a[i][j] &lt;&lt; <font color="#BC8F8F"><b>' '</b></font>;
    cout &lt;&lt; endl;
  }
  
  <i><font color="#B22222">// expected: 1.63333 1.3
</font></i>  <i><font color="#B22222">//           -0.166667 0.5
</font></i>  <i><font color="#B22222">//           2.36667 1.7
</font></i>  <i><font color="#B22222">//           -1.85 -1.35
</font></i>  cout &lt;&lt; <font color="#BC8F8F"><b>"Solution: "</b></font> &lt;&lt; endl;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; m; j++)
      cout &lt;&lt; b[i][j] &lt;&lt; <font color="#BC8F8F"><b>' '</b></font>;
    cout &lt;&lt; endl;
  }
}
</pre>
<hr>
</a><a name="file14">
<h1>ReducedRowEchelonForm.cc 14/27</h1>
<pre><i><font color="#B22222">// Reduced row echelon form via Gauss-Jordan elimination 
</font></i><i><font color="#B22222">// with partial pivoting.  This can be used for computing
</font></i><i><font color="#B22222">// the rank of a matrix.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(n^3)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT:    a[][] = an nxn matrix
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:   rref[][] = an nxm matrix (stored in a[][])
</font></i><i><font color="#B22222">//           returns rank of a[][]
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>

using namespace std;

<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>double</b></font> EPSILON = 1e-10;

<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>double</b></font> T;
<font color="#228B22"><b>typedef</b></font> vector&lt;T&gt; VT;
<font color="#228B22"><b>typedef</b></font> vector&lt;VT&gt; VVT;

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">rref</font></b>(VVT &amp;a) {
  <font color="#228B22"><b>int</b></font> n = a.size();
  <font color="#228B22"><b>int</b></font> m = a[0].size();
  <font color="#228B22"><b>int</b></font> r = 0;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> c = 0; c &lt; m; c++) {
    <font color="#228B22"><b>int</b></font> j = r;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = r+1; i &lt; n; i++) 
      <b><font color="#A020F0">if</font></b> (fabs(a[i][c]) &gt; fabs(a[j][c])) j = i;
    <b><font color="#A020F0">if</font></b> (fabs(a[j][c]) &lt; EPSILON) <b><font color="#A020F0">continue</font></b>;
    swap(a[j], a[r]);
   
    T s = 1.0 / a[r][c];
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; m; j++) a[r][j] *= s;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++) <b><font color="#A020F0">if</font></b> (i != r) {
      T t = a[i][c];
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; m; j++) a[i][j] -= t * a[r][j];
    }
    r++;
  }
  <b><font color="#A020F0">return</font></b> r;
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>(){
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> n = 5;
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> m = 4;
  <font color="#228B22"><b>double</b></font> A[n][m] = { {16,2,3,13},{5,11,10,8},{9,7,6,12},{4,14,15,1},{13,21,21,13} };
  VVT a(n);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; n; i++)
    a[i] = VT(A[i], A[i] + n);
  
  <font color="#228B22"><b>int</b></font> rank = rref (a);
  
  <i><font color="#B22222">// expected: 4
</font></i>  cout &lt;&lt; <font color="#BC8F8F"><b>"Rank: "</b></font> &lt;&lt; rank &lt;&lt; endl;
  
  <i><font color="#B22222">// expected: 1 0 0 1 
</font></i>  <i><font color="#B22222">//           0 1 0 3 
</font></i>  <i><font color="#B22222">//           0 0 1 -3 
</font></i>  <i><font color="#B22222">//           0 0 0 2.78206e-15 
</font></i>  <i><font color="#B22222">//           0 0 0 3.22398e-15
</font></i>  cout &lt;&lt; <font color="#BC8F8F"><b>"rref: "</b></font> &lt;&lt; endl;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; 5; i++){
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; 4; j++)
      cout &lt;&lt; a[i][j] &lt;&lt; <font color="#BC8F8F"><b>' '</b></font>;
    cout &lt;&lt; endl;
  }
  
}
</pre>
<hr>
</a><a name="file15">
<h1>FFT_new.cpp 15/27</h1>
<pre>#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cassert&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cstdio&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>

<font color="#228B22"><b>struct</b></font> cpx
{
  cpx(){}
  cpx(<font color="#228B22"><b>double</b></font> aa):a(aa){}
  cpx(<font color="#228B22"><b>double</b></font> aa, <font color="#228B22"><b>double</b></font> bb):a(aa),b(bb){}
  <font color="#228B22"><b>double</b></font> a;
  <font color="#228B22"><b>double</b></font> b;
  <font color="#228B22"><b>double</b></font> modsq(<font color="#228B22"><b>void</b></font>) <font color="#228B22"><b>const</b></font>
  {
    <b><font color="#A020F0">return</font></b> a * a + b * b;
  }
  cpx bar(<font color="#228B22"><b>void</b></font>) <font color="#228B22"><b>const</b></font>
  {
    <b><font color="#A020F0">return</font></b> cpx(a, -b);
  }
};

cpx <b><font color="#A020F0">operator</font></b> +(cpx a, cpx b)
{
  <b><font color="#A020F0">return</font></b> cpx(a.a + b.a, a.b + b.b);
}

cpx <b><font color="#A020F0">operator</font></b> *(cpx a, cpx b)
{
  <b><font color="#A020F0">return</font></b> cpx(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);
}

cpx <b><font color="#A020F0">operator</font></b> /(cpx a, cpx b)
{
  cpx r = a * b.bar();
  <b><font color="#A020F0">return</font></b> cpx(r.a / b.modsq(), r.b / b.modsq());
}

cpx <b><font color="#0000FF">EXP</font></b>(<font color="#228B22"><b>double</b></font> theta)
{
  <b><font color="#A020F0">return</font></b> cpx(cos(theta),sin(theta));
}

<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>double</b></font> two_pi = 4 * acos(0);

<i><font color="#B22222">// in:     input array
</font></i><i><font color="#B22222">// out:    output array
</font></i><i><font color="#B22222">// step:   {SET TO 1} (used internally)
</font></i><i><font color="#B22222">// size:   length of the input/output {MUST BE A POWER OF 2}
</font></i><i><font color="#B22222">// dir:    either plus or minus one (direction of the FFT)
</font></i><i><font color="#B22222">// RESULT: out[k] = \sum_{j=0}^{size - 1} in[j] * exp(dir * 2pi * i * j * k / size)
</font></i><font color="#228B22"><b>void</b></font> <b><font color="#0000FF">FFT</font></b>(cpx *in, cpx *out, <font color="#228B22"><b>int</b></font> step, <font color="#228B22"><b>int</b></font> size, <font color="#228B22"><b>int</b></font> dir)
{
  <b><font color="#A020F0">if</font></b>(size &lt; 1) <b><font color="#A020F0">return</font></b>;
  <b><font color="#A020F0">if</font></b>(size == 1)
  {
    out[0] = in[0];
    <b><font color="#A020F0">return</font></b>;
  }
  FFT(in, out, step * 2, size / 2, dir);
  FFT(in + step, out + size / 2, step * 2, size / 2, dir);
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; size / 2 ; i++)
  {
    cpx even = out[i];
    cpx odd = out[i + size / 2];
    out[i] = even + EXP(dir * two_pi * i / size) * odd;
    out[i + size / 2] = even + EXP(dir * two_pi * (i + size / 2) / size) * odd;
  }
}

<i><font color="#B22222">// Usage:
</font></i><i><font color="#B22222">// f[0...N-1] and g[0..N-1] are numbers
</font></i><i><font color="#B22222">// Want to compute the convolution h, defined by
</font></i><i><font color="#B22222">// h[n] = sum of f[k]g[n-k] (k = 0, ..., N-1).
</font></i><i><font color="#B22222">// Here, the index is cyclic; f[-1] = f[N-1], f[-2] = f[N-2], etc.
</font></i><i><font color="#B22222">// Let F[0...N-1] be FFT(f), and similarly, define G and H.
</font></i><i><font color="#B22222">// The convolution theorem says H[n] = F[n]G[n] (element-wise product).
</font></i><i><font color="#B22222">// To compute h[] in O(N log N) time, do the following:
</font></i><i><font color="#B22222">//   1. Compute F and G (pass dir = 1 as the argument).
</font></i><i><font color="#B22222">//   2. Get H by element-wise multiplying F and G.
</font></i><i><font color="#B22222">//   3. Get h by taking the inverse FFT (use dir = -1 as the argument)
</font></i><i><font color="#B22222">//      and *dividing by N*. DO NOT FORGET THIS SCALING FACTOR.
</font></i>
<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>(<font color="#228B22"><b>void</b></font>)
{
  printf(<font color="#BC8F8F"><b>"If rows come in identical pairs, then everything works.\n"</b></font>);
  
  cpx a[8] = {0, 1, cpx(1,3), cpx(0,5), 1, 0, 2, 0};
  cpx b[8] = {1, cpx(0,-2), cpx(0,1), 3, -1, -3, 1, -2};
  cpx A[8];
  cpx B[8];
  FFT(a, A, 1, 8, 1);
  FFT(b, B, 1, 8, 1);
  
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; 8 ; i++)
  {
    printf(<font color="#BC8F8F"><b>"%7.2lf%7.2lf"</b></font>, A[i].a, A[i].b);
  }
  printf(<font color="#BC8F8F"><b>"\n"</b></font>);
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; 8 ; i++)
  {
    cpx Ai(0,0);
    <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> j = 0 ; j &lt; 8 ; j++)
    {
      Ai = Ai + a[j] * EXP(j * i * two_pi / 8);
    }
    printf(<font color="#BC8F8F"><b>"%7.2lf%7.2lf"</b></font>, Ai.a, Ai.b);
  }
  printf(<font color="#BC8F8F"><b>"\n"</b></font>);
  
  cpx AB[8];
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; 8 ; i++)
    AB[i] = A[i] * B[i];
  cpx aconvb[8];
  FFT(AB, aconvb, 1, 8, -1);
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; 8 ; i++)
    aconvb[i] = aconvb[i] / 8;
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; 8 ; i++)
  {
    printf(<font color="#BC8F8F"><b>"%7.2lf%7.2lf"</b></font>, aconvb[i].a, aconvb[i].b);
  }
  printf(<font color="#BC8F8F"><b>"\n"</b></font>);
  <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i = 0 ; i &lt; 8 ; i++)
  {
    cpx aconvbi(0,0);
    <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> j = 0 ; j &lt; 8 ; j++)
    {
      aconvbi = aconvbi + a[j] * b[(8 + i - j) % 8];
    }
    printf(<font color="#BC8F8F"><b>"%7.2lf%7.2lf"</b></font>, aconvbi.a, aconvbi.b);
  }
  printf(<font color="#BC8F8F"><b>"\n"</b></font>);
  
  <b><font color="#A020F0">return</font></b> 0;
}

</pre>
<hr>
</a><a name="file16">
<h1>Simplex.cc 16/27</h1>
<pre><i><font color="#B22222">// Two-phase simplex algorithm for solving linear programs of the form
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//     maximize     c^T x
</font></i><i><font color="#B22222">//     subject to   Ax &lt;= b
</font></i><i><font color="#B22222">//                  x &gt;= 0
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT: A -- an m x n matrix
</font></i><i><font color="#B22222">//        b -- an m-dimensional vector
</font></i><i><font color="#B22222">//        c -- an n-dimensional vector
</font></i><i><font color="#B22222">//        x -- a vector where the optimal solution will be stored
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT: value of the optimal solution (infinity if unbounded
</font></i><i><font color="#B22222">//         above, nan if infeasible)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// To use this code, create an LPSolver object with A, b, and c as
</font></i><i><font color="#B22222">// arguments.  Then, call Solve(x).
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iomanip&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;limits&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>double</b></font> DOUBLE;
<font color="#228B22"><b>typedef</b></font> vector&lt;DOUBLE&gt; VD;
<font color="#228B22"><b>typedef</b></font> vector&lt;VD&gt; VVD;
<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;

<font color="#228B22"><b>const</b></font> DOUBLE EPS = 1e-9;

<font color="#228B22"><b>struct</b></font> LPSolver {
  <font color="#228B22"><b>int</b></font> m, n;
  VI B, N;
  VVD D;

  LPSolver(<font color="#228B22"><b>const</b></font> VVD &amp;A, <font color="#228B22"><b>const</b></font> VD &amp;b, <font color="#228B22"><b>const</b></font> VD &amp;c) : 
    m(b.size()), n(c.size()), N(n+1), B(m), D(m+2, VD(n+2)) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m; i++) <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n; j++) D[i][j] = A[i][j];
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m; i++) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i]; }
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n; j++) { N[j] = j; D[m][j] = -c[j]; }
    N[n] = -1; D[m+1][n] = 1;
  }
	   
  <font color="#228B22"><b>void</b></font> Pivot(<font color="#228B22"><b>int</b></font> r, <font color="#228B22"><b>int</b></font> s) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m+2; i++) <b><font color="#A020F0">if</font></b> (i != r)
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n+2; j++) <b><font color="#A020F0">if</font></b> (j != s)
	D[i][j] -= D[r][j] * D[i][s] / D[r][s];
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; n+2; j++) <b><font color="#A020F0">if</font></b> (j != s) D[r][j] /= D[r][s];
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m+2; i++) <b><font color="#A020F0">if</font></b> (i != r) D[i][s] /= -D[r][s];
    D[r][s] = 1.0 / D[r][s];
    swap(B[r], N[s]);
  }

  <font color="#228B22"><b>bool</b></font> Simplex(<font color="#228B22"><b>int</b></font> phase) {
    <font color="#228B22"><b>int</b></font> x = phase == 1 ? m+1 : m;
    <b><font color="#A020F0">while</font></b> (true) {
      <font color="#228B22"><b>int</b></font> s = -1;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt;= n; j++) {
	<b><font color="#A020F0">if</font></b> (phase == 2 &amp;&amp; N[j] == -1) <b><font color="#A020F0">continue</font></b>;
	<b><font color="#A020F0">if</font></b> (s == -1 || D[x][j] &lt; D[x][s] || D[x][j] == D[x][s] &amp;&amp; N[j] &lt; N[s]) s = j;
      }
      <b><font color="#A020F0">if</font></b> (D[x][s] &gt;= -EPS) <b><font color="#A020F0">return</font></b> true;
      <font color="#228B22"><b>int</b></font> r = -1;
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m; i++) {
	<b><font color="#A020F0">if</font></b> (D[i][s] &lt;= 0) <b><font color="#A020F0">continue</font></b>;
	<b><font color="#A020F0">if</font></b> (r == -1 || D[i][n+1] / D[i][s] &lt; D[r][n+1] / D[r][s] ||
	    D[i][n+1] / D[i][s] == D[r][n+1] / D[r][s] &amp;&amp; B[i] &lt; B[r]) r = i;
      }
      <b><font color="#A020F0">if</font></b> (r == -1) <b><font color="#A020F0">return</font></b> false;
      Pivot(r, s);
    }
  }

  DOUBLE Solve(VD &amp;x) {
    <font color="#228B22"><b>int</b></font> r = 0;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 1; i &lt; m; i++) <b><font color="#A020F0">if</font></b> (D[i][n+1] &lt; D[r][n+1]) r = i;
    <b><font color="#A020F0">if</font></b> (D[r][n+1] &lt;= -EPS) {
      Pivot(r, n);
      <b><font color="#A020F0">if</font></b> (!Simplex(1) || D[m+1][n+1] &lt; -EPS) <b><font color="#A020F0">return</font></b> -numeric_limits&lt;DOUBLE&gt;::infinity();
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m; i++) <b><font color="#A020F0">if</font></b> (B[i] == -1) {
	<font color="#228B22"><b>int</b></font> s = -1;
	<b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt;= n; j++) 
	  <b><font color="#A020F0">if</font></b> (s == -1 || D[i][j] &lt; D[i][s] || D[i][j] == D[i][s] &amp;&amp; N[j] &lt; N[s]) s = j;
	Pivot(i, s);
      }
    }
    <b><font color="#A020F0">if</font></b> (!Simplex(2)) <b><font color="#A020F0">return</font></b> numeric_limits&lt;DOUBLE&gt;::infinity();
    x = VD(n);
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m; i++) <b><font color="#A020F0">if</font></b> (B[i] &lt; n) x[B[i]] = D[i][n+1];
    <b><font color="#A020F0">return</font></b> D[m][n+1];
  }
};

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>() {

  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> m = 4;
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> n = 3;  
  DOUBLE _A[m][n] = {
    { 6, -1, 0 },
    { -1, -5, 0 },
    { 1, 5, 1 },
    { -1, -5, -1 }
  };
  DOUBLE _b[m] = { 10, -4, 5, -5 };
  DOUBLE _c[n] = { 1, -1, 0 };
  
  VVD A(m);
  VD b(_b, _b + m);
  VD c(_c, _c + n);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; m; i++) A[i] = VD(_A[i], _A[i] + n);

  LPSolver solver(A, b, c);
  VD x;
  DOUBLE value = solver.Solve(x);
  
  cerr &lt;&lt; <font color="#BC8F8F"><b>"VALUE: "</b></font>&lt;&lt; value &lt;&lt; endl;
  cerr &lt;&lt; <font color="#BC8F8F"><b>"SOLUTION:"</b></font>;
  <b><font color="#A020F0">for</font></b> (size_t i = 0; i &lt; x.size(); i++) cerr &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; x[i];
  cerr &lt;&lt; endl;
  <b><font color="#A020F0">return</font></b> 0;
}


</pre>
<hr>
</a><a name="file17">
<h1>FastDijkstra.cc 17/27</h1>
<pre><i><font color="#B22222">// Implementation of Dijkstra's algorithm using adjacency lists
</font></i><i><font color="#B22222">// and priority queue for efficiency.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(|E| log |V|)
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;queue&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;stdio.h&gt;</b></font>

using namespace std;
<font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> INF = 2000000000;
<font color="#228B22"><b>typedef</b></font> pair&lt;<font color="#228B22"><b>int</b></font>,<font color="#228B22"><b>int</b></font>&gt; PII;

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>(){
  
  <font color="#228B22"><b>int</b></font> N, s, t;
  scanf (<font color="#BC8F8F"><b>"%d%d%d"</b></font>, &amp;N, &amp;s, &amp;t);
  vector&lt;vector&lt;PII&gt; &gt; edges(N);
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; N; i++){
    <font color="#228B22"><b>int</b></font> M;
    scanf (<font color="#BC8F8F"><b>"%d"</b></font>, &amp;M);
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> j = 0; j &lt; M; j++){
      <font color="#228B22"><b>int</b></font> vertex, dist;
      scanf (<font color="#BC8F8F"><b>"%d%d"</b></font>, &amp;vertex, &amp;dist);
      edges[i].push_back (make_pair (dist, vertex)); <i><font color="#B22222">// note order of arguments here
</font></i>    }
  }
  
  <i><font color="#B22222">// use priority queue in which top element has the "smallest" priority
</font></i>  priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; Q;
  vector&lt;<font color="#228B22"><b>int</b></font>&gt; dist(N, INF), dad(N, -1);
  Q.push (make_pair (0, s));
  dist[s] = 0;
  <b><font color="#A020F0">while</font></b> (!Q.empty()){
    PII p = Q.top();
    <b><font color="#A020F0">if</font></b> (p.second == t) <b><font color="#A020F0">break</font></b>;
    Q.pop();
    
    <font color="#228B22"><b>int</b></font> here = p.second;
    <b><font color="#A020F0">for</font></b> (vector&lt;PII&gt;::iterator it=edges[here].begin(); it!=edges[here].end(); it++){
      <b><font color="#A020F0">if</font></b> (dist[here] + it-&gt;first &lt; dist[it-&gt;second]){
        dist[it-&gt;second] = dist[here] + it-&gt;first;
        dad[it-&gt;second] = here;
        Q.push (make_pair (dist[it-&gt;second], it-&gt;second));
      }
    }
  }
  
  printf (<font color="#BC8F8F"><b>"%d\n"</b></font>, dist[t]);
  <b><font color="#A020F0">if</font></b> (dist[t] &lt; INF)
    <b><font color="#A020F0">for</font></b>(<font color="#228B22"><b>int</b></font> i=t;i!=-1;i=dad[i])
      printf (<font color="#BC8F8F"><b>"%d%c"</b></font>, i, (i==s?<font color="#BC8F8F"><b>'\n'</b></font>:<font color="#BC8F8F"><b>' '</b></font>));
    
  <b><font color="#A020F0">return</font></b> 0;
}
</pre>
<hr>
</a><a name="file18">
<h1>SCC.cc 18/27</h1>
<pre>#<b><font color="#5F9EA0">include&lt;memory.h&gt;</font></b>
<font color="#228B22"><b>struct</b></font> edge{<font color="#228B22"><b>int</b></font> e, nxt;};
<font color="#228B22"><b>int</b></font> V, E;
edge e[MAXE], er[MAXE];
<font color="#228B22"><b>int</b></font> sp[MAXV], spr[MAXV];
<font color="#228B22"><b>int</b></font> group_cnt, group_num[MAXV];
<font color="#228B22"><b>bool</b></font> v[MAXV];
<font color="#228B22"><b>int</b></font> stk[MAXV];
<font color="#228B22"><b>void</b></font> <b><font color="#0000FF">fill_forward</font></b>(<font color="#228B22"><b>int</b></font> x)
{
  <font color="#228B22"><b>int</b></font> i;
  v[x]=true;
  <b><font color="#A020F0">for</font></b>(i=sp[x];i;i=e[i].nxt) <b><font color="#A020F0">if</font></b>(!v[e[i].e]) fill_forward(e[i].e);
  stk[++stk[0]]=x;
}
<font color="#228B22"><b>void</b></font> <b><font color="#0000FF">fill_backward</font></b>(<font color="#228B22"><b>int</b></font> x)
{
  <font color="#228B22"><b>int</b></font> i;
  v[x]=false;
  group_num[x]=group_cnt;
  <b><font color="#A020F0">for</font></b>(i=spr[x];i;i=er[i].nxt) <b><font color="#A020F0">if</font></b>(v[er[i].e]) fill_backward(er[i].e);
}
<font color="#228B22"><b>void</b></font> <b><font color="#0000FF">add_edge</font></b>(<font color="#228B22"><b>int</b></font> v1, <font color="#228B22"><b>int</b></font> v2) <i><font color="#B22222">//add edge v1-&gt;v2
</font></i>{
  e [++E].e=v2; e [E].nxt=sp [v1]; sp [v1]=E;
  er[  E].e=v1; er[E].nxt=spr[v2]; spr[v2]=E;
}
<font color="#228B22"><b>void</b></font> <b><font color="#0000FF">SCC</font></b>()
{
  <font color="#228B22"><b>int</b></font> i;
  stk[0]=0;
  memset(v, false, <b><font color="#A020F0">sizeof</font></b>(v));
  <b><font color="#A020F0">for</font></b>(i=1;i&lt;=V;i++) <b><font color="#A020F0">if</font></b>(!v[i]) fill_forward(i);
  group_cnt=0;
  <b><font color="#A020F0">for</font></b>(i=stk[0];i&gt;=1;i--) <b><font color="#A020F0">if</font></b>(v[stk[i]]){group_cnt++; fill_backward(stk[i]);}
}

</pre>
<hr>
</a><a name="file19">
<h1>SuffixArray.cc 19/27</h1>
<pre><i><font color="#B22222">// Suffix array construction in O(L log^2 L) time.  Routine for
</font></i><i><font color="#B22222">// computing the length of the longest common prefix of any two
</font></i><i><font color="#B22222">// suffixes in O(log L) time.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// INPUT:   string s
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// OUTPUT:  array suffix[] such that suffix[i] = index (from 0 to L-1)
</font></i><i><font color="#B22222">//          of substring s[i...L-1] in the list of sorted suffixes.
</font></i><i><font color="#B22222">//          That is, if we take the inverse of the permutation suffix[],
</font></i><i><font color="#B22222">//          we get the actual suffix array.
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;string&gt;</b></font>

using namespace std;

<font color="#228B22"><b>struct</b></font> SuffixArray {
  <font color="#228B22"><b>const</b></font> <font color="#228B22"><b>int</b></font> L;
  string s;
  vector&lt;vector&lt;<font color="#228B22"><b>int</b></font>&gt; &gt; P;
  vector&lt;pair&lt;pair&lt;<font color="#228B22"><b>int</b></font>,<font color="#228B22"><b>int</b></font>&gt;,<font color="#228B22"><b>int</b></font>&gt; &gt; M;

  SuffixArray(<font color="#228B22"><b>const</b></font> string &amp;s) : L(s.length()), s(s), P(1, vector&lt;<font color="#228B22"><b>int</b></font>&gt;(L, 0)), M(L) {
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; L; i++) P[0][i] = <font color="#228B22"><b>int</b></font>(s[i]);
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> skip = 1, level = 1; skip &lt; L; skip *= 2, level++) {
      P.push_back(vector&lt;<font color="#228B22"><b>int</b></font>&gt;(L, 0));
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; L; i++) 
	M[i] = make_pair(make_pair(P[level-1][i], i + skip &lt; L ? P[level-1][i + skip] : -1000), i);
      sort(M.begin(), M.end());
      <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; L; i++) 
	P[level][M[i].second] = (i &gt; 0 &amp;&amp; M[i].first == M[i-1].first) ? P[level][M[i-1].second] : i;
    }    
  }

  vector&lt;<font color="#228B22"><b>int</b></font>&gt; GetSuffixArray() { <b><font color="#A020F0">return</font></b> P.back(); }

  <i><font color="#B22222">// returns the length of the longest common prefix of s[i...L-1] and s[j...L-1]
</font></i>  <font color="#228B22"><b>int</b></font> LongestCommonPrefix(<font color="#228B22"><b>int</b></font> i, <font color="#228B22"><b>int</b></font> j) {
    <font color="#228B22"><b>int</b></font> len = 0;
    <b><font color="#A020F0">if</font></b> (i == j) <b><font color="#A020F0">return</font></b> L - i;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> k = P.size() - 1; k &gt;= 0 &amp;&amp; i &lt; L &amp;&amp; j &lt; L; k--) {
      <b><font color="#A020F0">if</font></b> (P[k][i] == P[k][j]) {
	i += 1 &lt;&lt; k;
	j += 1 &lt;&lt; k;
	len += 1 &lt;&lt; k;
      }
    }
    <b><font color="#A020F0">return</font></b> len;
  }
};

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>() {

  <i><font color="#B22222">// bobocel is the 0'th suffix
</font></i>  <i><font color="#B22222">//  obocel is the 5'th suffix
</font></i>  <i><font color="#B22222">//   bocel is the 1'st suffix
</font></i>  <i><font color="#B22222">//    ocel is the 6'th suffix
</font></i>  <i><font color="#B22222">//     cel is the 2'nd suffix
</font></i>  <i><font color="#B22222">//      el is the 3'rd suffix
</font></i>  <i><font color="#B22222">//       l is the 4'th suffix
</font></i>  SuffixArray suffix(<font color="#BC8F8F"><b>"bobocel"</b></font>);
  vector&lt;<font color="#228B22"><b>int</b></font>&gt; v = suffix.GetSuffixArray();
  
  <i><font color="#B22222">// Expected output: 0 5 1 6 2 3 4
</font></i>  <i><font color="#B22222">//                  2
</font></i>  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; <font color="#BC8F8F"><b>" "</b></font>;
  cout &lt;&lt; endl;
  cout &lt;&lt; suffix.LongestCommonPrefix(0, 2) &lt;&lt; endl;
}
</pre>
<hr>
</a><a name="file20">
<h1>BIT.cc 20/27</h1>
<pre>#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
using namespace std;

#<b><font color="#5F9EA0">define</font></b> <font color="#B8860B">LOGSZ</font> 17

<font color="#228B22"><b>int</b></font> tree[(1&lt;&lt;LOGSZ)+1];
<font color="#228B22"><b>int</b></font> N = (1&lt;&lt;LOGSZ);

<i><font color="#B22222">// add v to value at x
</font></i><font color="#228B22"><b>void</b></font> <b><font color="#0000FF">set</font></b>(<font color="#228B22"><b>int</b></font> x, <font color="#228B22"><b>int</b></font> v) {
  <b><font color="#A020F0">while</font></b>(x &lt;= N) {
    tree[x] += v;
    x += (x &amp; -x);
  }
}

<i><font color="#B22222">// get cumulative sum up to and including x
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">get</font></b>(<font color="#228B22"><b>int</b></font> x) {
  <font color="#228B22"><b>int</b></font> res = 0;
  <b><font color="#A020F0">while</font></b>(x) {
    res += tree[x];
    x -= (x &amp; -x);
  }
  <b><font color="#A020F0">return</font></b> res;
}

<i><font color="#B22222">// get largest value with cumulative sum less than or equal to x;
</font></i><i><font color="#B22222">// for smallest, pass x-1 and add 1 to result
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">getind</font></b>(<font color="#228B22"><b>int</b></font> x) {
  <font color="#228B22"><b>int</b></font> idx = 0, mask = N;
  <b><font color="#A020F0">while</font></b>(mask &amp;&amp; idx &lt; N) {
    <font color="#228B22"><b>int</b></font> t = idx + mask;
    <b><font color="#A020F0">if</font></b>(x &gt;= tree[t]) {
      idx = t;
      x -= tree[t];
    }
    mask &gt;&gt;= 1;
  }
  <b><font color="#A020F0">return</font></b> idx;
}
</pre>
<hr>
</a><a name="file21">
<h1>UnionFind.cc 21/27</h1>
<pre><i><font color="#B22222">//union-find set: the vector/array contains the parent of each node
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">find</font></b>(vector &lt;<font color="#228B22"><b>int</b></font>&gt;&amp; C, <font color="#228B22"><b>int</b></font> x){<b><font color="#A020F0">return</font></b> (C[x]==x) ? x : C[x]=find(C, C[x]);} <i><font color="#B22222">//C++
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">find</font></b>(<font color="#228B22"><b>int</b></font> x){<b><font color="#A020F0">return</font></b> (C[x]==x)?<b><font color="#5F9EA0">x</font></b>:C[x]=find(C[x]);} <i><font color="#B22222">//C
</font></i></pre>
<hr>
</a><a name="file22">
<h1>KDTree.cc 22/27</h1>
<pre><i><font color="#B22222">// --------------------------------------------------------------------------
</font></i><i><font color="#B22222">// A straightforward, but probably sub-optimal KD-tree implmentation that's
</font></i><i><font color="#B22222">// probably good enough for most things (current it's a 2D-tree)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//  - constructs from n points in O(n lg^2 n) time
</font></i><i><font color="#B22222">//  - handles nearest-neighbor query in O(lg n) if points are well distributed
</font></i><i><font color="#B22222">//  - worst case for nearest-neighbor may be linear in pathological case
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Sonny Chan, Stanford University, April 2009
</font></i><i><font color="#B22222">// --------------------------------------------------------------------------
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;limits&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cstdlib&gt;</b></font>

using namespace std;

<i><font color="#B22222">// number type for coordinates, and its maximum value
</font></i><font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> ntype;
<font color="#228B22"><b>const</b></font> ntype sentry = numeric_limits&lt;ntype&gt;::max();

<i><font color="#B22222">// point structure for 2D-tree, can be extended to 3D
</font></i><font color="#228B22"><b>struct</b></font> point {
    ntype x, y;
    point(ntype xx = 0, ntype yy = 0) : x(xx), y(yy) {}
};

<font color="#228B22"><b>bool</b></font> <b><font color="#A020F0">operator</font></b>==(<font color="#228B22"><b>const</b></font> point &amp;a, <font color="#228B22"><b>const</b></font> point &amp;b)
{
    <b><font color="#A020F0">return</font></b> a.x == b.x &amp;&amp; a.y == b.y;
}

<i><font color="#B22222">// sorts points on x-coordinate
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">on_x</font></b>(<font color="#228B22"><b>const</b></font> point &amp;a, <font color="#228B22"><b>const</b></font> point &amp;b)
{
    <b><font color="#A020F0">return</font></b> a.x &lt; b.x;
}

<i><font color="#B22222">// sorts points on y-coordinate
</font></i><font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">on_y</font></b>(<font color="#228B22"><b>const</b></font> point &amp;a, <font color="#228B22"><b>const</b></font> point &amp;b)
{
    <b><font color="#A020F0">return</font></b> a.y &lt; b.y;
}

<i><font color="#B22222">// squared distance between points
</font></i>ntype <b><font color="#0000FF">pdist2</font></b>(<font color="#228B22"><b>const</b></font> point &amp;a, <font color="#228B22"><b>const</b></font> point &amp;b)
{
    ntype dx = a.x-b.x, dy = a.y-b.y;
    <b><font color="#A020F0">return</font></b> dx*dx + dy*dy;
}

<i><font color="#B22222">// bounding box for a set of points
</font></i><font color="#228B22"><b>struct</b></font> bbox
{
    ntype x0, x1, y0, y1;
    
    bbox() : x0(sentry), x1(-sentry), y0(sentry), y1(-sentry) {}
    
    <i><font color="#B22222">// computes bounding box from a bunch of points
</font></i>    <font color="#228B22"><b>void</b></font> compute(<font color="#228B22"><b>const</b></font> vector&lt;point&gt; &amp;v) {
        <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; v.size(); ++i) {
            x0 = min(x0, v[i].x);   x1 = max(x1, v[i].x);
            y0 = min(y0, v[i].y);   y1 = max(y1, v[i].y);
        }
    }
    
    <i><font color="#B22222">// squared distance between a point and this bbox, 0 if inside
</font></i>    ntype distance(<font color="#228B22"><b>const</b></font> point &amp;p) {
        <b><font color="#A020F0">if</font></b> (p.x &lt; x0) {
            <b><font color="#A020F0">if</font></b> (p.y &lt; y0)       <b><font color="#A020F0">return</font></b> pdist2(point(x0, y0), p);
            <b><font color="#A020F0">else</font></b> <b><font color="#A020F0">if</font></b> (p.y &gt; y1)  <b><font color="#A020F0">return</font></b> pdist2(point(x0, y1), p);
            <b><font color="#A020F0">else</font></b>                <b><font color="#A020F0">return</font></b> pdist2(point(x0, p.y), p);
        }
        <b><font color="#A020F0">else</font></b> <b><font color="#A020F0">if</font></b> (p.x &gt; x1) {
            <b><font color="#A020F0">if</font></b> (p.y &lt; y0)       <b><font color="#A020F0">return</font></b> pdist2(point(x1, y0), p);
            <b><font color="#A020F0">else</font></b> <b><font color="#A020F0">if</font></b> (p.y &gt; y1)  <b><font color="#A020F0">return</font></b> pdist2(point(x1, y1), p);
            <b><font color="#A020F0">else</font></b>                <b><font color="#A020F0">return</font></b> pdist2(point(x1, p.y), p);
        }
        <b><font color="#A020F0">else</font></b> {
            <b><font color="#A020F0">if</font></b> (p.y &lt; y0)       <b><font color="#A020F0">return</font></b> pdist2(point(p.x, y0), p);
            <b><font color="#A020F0">else</font></b> <b><font color="#A020F0">if</font></b> (p.y &gt; y1)  <b><font color="#A020F0">return</font></b> pdist2(point(p.x, y1), p);
            <b><font color="#A020F0">else</font></b>                <b><font color="#A020F0">return</font></b> 0;
        }
    }
};

<i><font color="#B22222">// stores a single node of the kd-tree, either internal or leaf
</font></i><font color="#228B22"><b>struct</b></font> kdnode 
{
    <font color="#228B22"><b>bool</b></font> leaf;      <i><font color="#B22222">// true if this is a leaf node (has one point)
</font></i>    point pt;       <i><font color="#B22222">// the single point of this is a leaf
</font></i>    bbox bound;     <i><font color="#B22222">// bounding box for set of points in children
</font></i>    
    kdnode *first, *second; <i><font color="#B22222">// two children of this kd-node
</font></i>    
    kdnode() : leaf(false), first(0), second(0) {}
    ~kdnode() { <b><font color="#A020F0">if</font></b> (first) <b><font color="#A020F0">delete</font></b> first; <b><font color="#A020F0">if</font></b> (second) <b><font color="#A020F0">delete</font></b> second; }
    
    <i><font color="#B22222">// intersect a point with this node (returns squared distance)
</font></i>    ntype intersect(<font color="#228B22"><b>const</b></font> point &amp;p) {
        <b><font color="#A020F0">return</font></b> bound.distance(p);
    }
    
    <i><font color="#B22222">// recursively builds a kd-tree from a given cloud of points
</font></i>    <font color="#228B22"><b>void</b></font> construct(vector&lt;point&gt; &amp;vp)
    {
        <i><font color="#B22222">// compute bounding box for points at this node
</font></i>        bound.compute(vp);
        
        <i><font color="#B22222">// if we're down to one point, then we're a leaf node
</font></i>        <b><font color="#A020F0">if</font></b> (vp.size() == 1) {
            leaf = true;
            pt = vp[0];
        }
        <b><font color="#A020F0">else</font></b> {
            <i><font color="#B22222">// split on x if the bbox is wider than high (not best heuristic...)
</font></i>            <b><font color="#A020F0">if</font></b> (bound.x1-bound.x0 &gt;= bound.y1-bound.y0)
                sort(vp.begin(), vp.end(), on_x);
            <i><font color="#B22222">// otherwise split on y-coordinate
</font></i>            <b><font color="#A020F0">else</font></b>
                sort(vp.begin(), vp.end(), on_y);
            
            <i><font color="#B22222">// divide by taking half the array for each child
</font></i>            <i><font color="#B22222">// (not best performance if many duplicates in the middle)
</font></i>            <font color="#228B22"><b>int</b></font> half = vp.size()/2;
            vector&lt;point&gt; vl(vp.begin(), vp.begin()+half);
            vector&lt;point&gt; vr(vp.begin()+half, vp.end());
            first = <b><font color="#A020F0">new</font></b> kdnode();   first-&gt;construct(vl);
            second = <b><font color="#A020F0">new</font></b> kdnode();  second-&gt;construct(vr);            
        }
    }
};

<i><font color="#B22222">// simple kd-tree class to hold the tree and handle queries
</font></i><font color="#228B22"><b>struct</b></font> kdtree
{
    kdnode *root;
    
    <i><font color="#B22222">// constructs a kd-tree from a points (copied here, as it sorts them)
</font></i>    kdtree(<font color="#228B22"><b>const</b></font> vector&lt;point&gt; &amp;vp) {
        vector&lt;point&gt; v(vp.begin(), vp.end());
        root = <b><font color="#A020F0">new</font></b> kdnode();
        root-&gt;construct(v);
    }
    ~kdtree() { <b><font color="#A020F0">delete</font></b> root; }
    
    <i><font color="#B22222">// recursive search method returns squared distance to nearest point
</font></i>    ntype search(kdnode *node, <font color="#228B22"><b>const</b></font> point &amp;p)
    {
        <b><font color="#A020F0">if</font></b> (node-&gt;leaf) {
            <i><font color="#B22222">// commented special case tells a point not to find itself
</font></i><i><font color="#B22222">//            if (p == node-&gt;pt) return sentry;
</font></i><i><font color="#B22222">//            else               
</font></i>                <b><font color="#A020F0">return</font></b> pdist2(p, node-&gt;pt);
        }
        
        ntype bfirst = node-&gt;first-&gt;intersect(p);
        ntype bsecond = node-&gt;second-&gt;intersect(p);
        
        <i><font color="#B22222">// choose the side with the closest bounding box to search first
</font></i>        <i><font color="#B22222">// (note that the other side is also searched if needed)
</font></i>        <b><font color="#A020F0">if</font></b> (bfirst &lt; bsecond) {
            ntype best = search(node-&gt;first, p);
            <b><font color="#A020F0">if</font></b> (bsecond &lt; best)
                best = min(best, search(node-&gt;second, p));
            <b><font color="#A020F0">return</font></b> best;
        }
        <b><font color="#A020F0">else</font></b> {
            ntype best = search(node-&gt;second, p);
            <b><font color="#A020F0">if</font></b> (bfirst &lt; best)
                best = min(best, search(node-&gt;first, p));
            <b><font color="#A020F0">return</font></b> best;
        }
    }
    
    <i><font color="#B22222">// squared distance to the nearest 
</font></i>    ntype nearest(<font color="#228B22"><b>const</b></font> point &amp;p) {
        <b><font color="#A020F0">return</font></b> search(root, p);
    }
};

<i><font color="#B22222">// --------------------------------------------------------------------------
</font></i><i><font color="#B22222">// some basic test code here
</font></i>
<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>()
{
    <i><font color="#B22222">// generate some random points for a kd-tree
</font></i>    vector&lt;point&gt; vp;
    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; 100000; ++i) {
        vp.push_back(point(rand()%100000, rand()%100000));
    }
    kdtree tree(vp);
    
    <i><font color="#B22222">// query some points
</font></i>    <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; 10; ++i) {
        point q(rand()%100000, rand()%100000);
        cout &lt;&lt; <font color="#BC8F8F"><b>"Closest squared distance to ("</b></font> &lt;&lt; q.x &lt;&lt; <font color="#BC8F8F"><b>", "</b></font> &lt;&lt; q.y &lt;&lt; <font color="#BC8F8F"><b>")"</b></font>
             &lt;&lt; <font color="#BC8F8F"><b>" is "</b></font> &lt;&lt; tree.nearest(q) &lt;&lt; endl;
    }    

    <b><font color="#A020F0">return</font></b> 0;
}

<i><font color="#B22222">// --------------------------------------------------------------------------
</font></i></pre>
<hr>
</a><a name="file23">
<h1>LongestIncreasingSubsequence.cc 23/27</h1>
<pre><i><font color="#B22222">// Given a list of numbers of length n, this routine extracts a 
</font></i><i><font color="#B22222">// longest increasing subsequence.
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// Running time: O(n log n)
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//   INPUT: a vector of integers
</font></i><i><font color="#B22222">//   OUTPUT: a vector containing the longest increasing subsequence
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;algorithm&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;
<font color="#228B22"><b>typedef</b></font> pair&lt;<font color="#228B22"><b>int</b></font>,<font color="#228B22"><b>int</b></font>&gt; PII;
<font color="#228B22"><b>typedef</b></font> vector&lt;PII&gt; VPII;

#<b><font color="#5F9EA0">define</font></b> <font color="#B8860B">STRICTLY_INCREASNG</font>

VI <b><font color="#0000FF">LongestIncreasingSubsequence</font></b>(VI v) {
  VPII best;
  VI dad(v.size(), -1);
  
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = 0; i &lt; v.size(); i++) {
#<b><font color="#5F9EA0">ifdef</font></b> <font color="#B8860B">STRICTLY_INCREASNG</font>
    PII item = make_pair(v[i], 0);
    VPII::iterator it = lower_bound(best.begin(), best.end(), item);
    item.second = i;
#<b><font color="#5F9EA0">else</font></b>
    PII item = make_pair(v[i], i);
    VPII::iterator it = upper_bound(best.begin(), best.end(), item);
#<b><font color="#5F9EA0">endif</font></b>
    <b><font color="#A020F0">if</font></b> (it == best.end()) {
      dad[i] = (best.size() == 0 ? -1 : best.back().second);
      best.push_back(item);
    } <b><font color="#A020F0">else</font></b> {
      dad[i] = dad[it-&gt;second];
      *it = item;
    }
  }
  
  VI ret;
  <b><font color="#A020F0">for</font></b> (<font color="#228B22"><b>int</b></font> i = best.back().second; i &gt;= 0; i = dad[i])
    ret.push_back(v[i]);
  reverse(ret.begin(), ret.end());
  <b><font color="#A020F0">return</font></b> ret;
}
</pre>
<hr>
</a><a name="file24">
<h1>Dates.cc 24/27</h1>
<pre><i><font color="#B22222">// Routines for performing computations on dates.  In these routines,
</font></i><i><font color="#B22222">// months are expressed as integers from 1 to 12, days are expressed
</font></i><i><font color="#B22222">// as integers from 1 to 31, and years are expressed as 4-digit
</font></i><i><font color="#B22222">// integers.
</font></i>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;string&gt;</b></font>

using namespace std;

string dayOfWeek[] = {<font color="#BC8F8F"><b>"Mon"</b></font>, <font color="#BC8F8F"><b>"Tue"</b></font>, <font color="#BC8F8F"><b>"Wed"</b></font>, <font color="#BC8F8F"><b>"Thu"</b></font>, <font color="#BC8F8F"><b>"Fri"</b></font>, <font color="#BC8F8F"><b>"Sat"</b></font>, <font color="#BC8F8F"><b>"Sun"</b></font>};

<i><font color="#B22222">// converts Gregorian date to integer (Julian day number)
</font></i><font color="#228B22"><b>int</b></font> <b><font color="#0000FF">dateToInt</font></b> (<font color="#228B22"><b>int</b></font> m, <font color="#228B22"><b>int</b></font> d, <font color="#228B22"><b>int</b></font> y){  
  <b><font color="#A020F0">return</font></b> 
    1461 * (y + 4800 + (m - 14) / 12) / 4 +
    367 * (m - 2 - (m - 14) / 12 * 12) / 12 - 
    3 * ((y + 4900 + (m - 14) / 12) / 100) / 4 + 
    d - 32075;
}

<i><font color="#B22222">// converts integer (Julian day number) to Gregorian date: month/day/year
</font></i><font color="#228B22"><b>void</b></font> <b><font color="#0000FF">intToDate</font></b> (<font color="#228B22"><b>int</b></font> jd, <font color="#228B22"><b>int</b></font> &amp;m, <font color="#228B22"><b>int</b></font> &amp;d, <font color="#228B22"><b>int</b></font> &amp;y){
  <font color="#228B22"><b>int</b></font> x, n, i, j;
  
  x = jd + 68569;
  n = 4 * x / 146097;
  x -= (146097 * n + 3) / 4;
  i = (4000 * (x + 1)) / 1461001;
  x -= 1461 * i / 4 - 31;
  j = 80 * x / 2447;
  d = x - 2447 * j / 80;
  x = j / 11;
  m = j + 2 - 12 * x;
  y = 100 * (n - 49) + i + x;
}

<i><font color="#B22222">// converts integer (Julian day number) to day of week
</font></i>string <b><font color="#0000FF">intToDay</font></b> (<font color="#228B22"><b>int</b></font> jd){
  <b><font color="#A020F0">return</font></b> dayOfWeek[jd % 7];
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b> (<font color="#228B22"><b>int</b></font> argc, <font color="#228B22"><b>char</b></font> **argv){
  <font color="#228B22"><b>int</b></font> jd = dateToInt (3, 24, 2004);
  <font color="#228B22"><b>int</b></font> m, d, y;
  intToDate (jd, m, d, y);
  string day = intToDay (jd);
  
  <i><font color="#B22222">// expected output:
</font></i>  <i><font color="#B22222">//    2453089
</font></i>  <i><font color="#B22222">//    3/24/2004
</font></i>  <i><font color="#B22222">//    Wed
</font></i>  cout &lt;&lt; jd &lt;&lt; endl
    &lt;&lt; m &lt;&lt; <font color="#BC8F8F"><b>"/"</b></font> &lt;&lt; d &lt;&lt; <font color="#BC8F8F"><b>"/"</b></font> &lt;&lt; y &lt;&lt; endl
    &lt;&lt; day &lt;&lt; endl;
}
</pre>
<hr>
</a><a name="file25">
<h1>LogLan.java 25/27</h1>
<pre><i><font color="#B22222">// Code which demonstrates the use of Java's regular expression libraries.
</font></i><i><font color="#B22222">// This is a solution for 
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">//   Loglan: a logical language
</font></i><i><font color="#B22222">//   http://acm.uva.es/p/v1/134.html
</font></i><i><font color="#B22222">//
</font></i><i><font color="#B22222">// In this problem, we are given a regular language, whose rules can be
</font></i><i><font color="#B22222">// inferred directly from the code.  For each sentence in the input, we must
</font></i><i><font color="#B22222">// determine whether the sentence matches the regular expression or not.  The
</font></i><i><font color="#B22222">// code consists of (1) building the regular expression (which is fairly
</font></i><i><font color="#B22222">// complex) and (2) using the regex to match sentences.
</font></i>
<b><font color="#A020F0">import</font></b> java.util.*;
<b><font color="#A020F0">import</font></b> java.util.regex.*;

<b><font color="#A020F0">public</font></b> <b><font color="#A020F0">class</font></b> LogLan {

    <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> String BuildRegex (){
	String space = <font color="#BC8F8F"><b>" +"</b></font>;

	String A = <font color="#BC8F8F"><b>"([aeiou])"</b></font>;
	String C = <font color="#BC8F8F"><b>"([a-z&amp;&amp;[^aeiou]])"</b></font>;
	String MOD = <font color="#BC8F8F"><b>"(g"</b></font> + A + <font color="#BC8F8F"><b>")"</b></font>;
	String BA = <font color="#BC8F8F"><b>"(b"</b></font> + A + <font color="#BC8F8F"><b>")"</b></font>;
	String DA = <font color="#BC8F8F"><b>"(d"</b></font> + A + <font color="#BC8F8F"><b>")"</b></font>;
	String LA = <font color="#BC8F8F"><b>"(l"</b></font> + A + <font color="#BC8F8F"><b>")"</b></font>;
	String NAM = <font color="#BC8F8F"><b>"([a-z]*"</b></font> + C + <font color="#BC8F8F"><b>")"</b></font>;
	String PREDA = <font color="#BC8F8F"><b>"("</b></font> + C + C + A + C + A + <font color="#BC8F8F"><b>"|"</b></font> + C + A + C + C + A + <font color="#BC8F8F"><b>")"</b></font>;

	String predstring = <font color="#BC8F8F"><b>"("</b></font> + PREDA + <font color="#BC8F8F"><b>"("</b></font> + space + PREDA + <font color="#BC8F8F"><b>")*)"</b></font>;
	String predname = <font color="#BC8F8F"><b>"("</b></font> + LA + space + predstring + <font color="#BC8F8F"><b>"|"</b></font> + NAM + <font color="#BC8F8F"><b>")"</b></font>;
	String preds = <font color="#BC8F8F"><b>"("</b></font> + predstring + <font color="#BC8F8F"><b>"("</b></font> + space + A + space + predstring + <font color="#BC8F8F"><b>")*)"</b></font>;
	String predclaim = <font color="#BC8F8F"><b>"("</b></font> + predname + space + BA + space + preds + <font color="#BC8F8F"><b>"|"</b></font> + DA + space +
            preds + <font color="#BC8F8F"><b>")"</b></font>;
	String verbpred = <font color="#BC8F8F"><b>"("</b></font> + MOD + space + predstring + <font color="#BC8F8F"><b>")"</b></font>;
	String statement = <font color="#BC8F8F"><b>"("</b></font> + predname + space + verbpred + space + predname + <font color="#BC8F8F"><b>"|"</b></font> + 
            predname + space + verbpred + <font color="#BC8F8F"><b>")"</b></font>;
	String sentence = <font color="#BC8F8F"><b>"("</b></font> + statement + <font color="#BC8F8F"><b>"|"</b></font> + predclaim + <font color="#BC8F8F"><b>")"</b></font>;

	<b><font color="#A020F0">return</font></b> <font color="#BC8F8F"><b>"^"</b></font> + sentence + <font color="#BC8F8F"><b>"$"</b></font>;
    }

    <b><font color="#A020F0">public</font></b> <b><font color="#A020F0">static</font></b> <b><font color="#A020F0">void</font></b> main (String args[]){

	String regex = BuildRegex();
	Pattern pattern = Pattern.compile (regex);
	
	Scanner s = <b><font color="#A020F0">new</font></b> Scanner(System.in);
	<b><font color="#A020F0">while</font></b> (<b><font color="#A020F0">true</font></b>) {

            <i><font color="#B22222">// In this problem, each sentence consists of multiple lines, where the last 
</font></i>	    <i><font color="#B22222">// line is terminated by a period.  The code below reads lines until
</font></i>	    <i><font color="#B22222">// encountering a line whose final character is a '.'.  Note the use of
</font></i>            <i><font color="#B22222">//
</font></i>            <i><font color="#B22222">//    s.length() to get length of string
</font></i>            <i><font color="#B22222">//    s.charAt() to extract characters from a Java string
</font></i>            <i><font color="#B22222">//    s.trim() to remove whitespace from the beginning and end of Java string
</font></i>            <i><font color="#B22222">//
</font></i>            <i><font color="#B22222">// Other useful String manipulation methods include
</font></i>            <i><font color="#B22222">//
</font></i>            <i><font color="#B22222">//    s.compareTo(t) &lt; 0 if s &lt; t, lexicographically
</font></i>            <i><font color="#B22222">//    s.indexOf("apple") returns index of first occurrence of "apple" in s
</font></i>            <i><font color="#B22222">//    s.lastIndexOf("apple") returns index of last occurrence of "apple" in s
</font></i>            <i><font color="#B22222">//    s.replace(c,d) replaces occurrences of character c with d
</font></i>            <i><font color="#B22222">//    s.startsWith("apple) returns (s.indexOf("apple") == 0)
</font></i>            <i><font color="#B22222">//    s.toLowerCase() / s.toUpperCase() returns a new lower/uppercased string
</font></i>            <i><font color="#B22222">//
</font></i>            <i><font color="#B22222">//    Integer.parseInt(s) converts s to an integer (32-bit)
</font></i>            <i><font color="#B22222">//    Long.parseLong(s) converts s to a long (64-bit)
</font></i>            <i><font color="#B22222">//    Double.parseDouble(s) converts s to a double
</font></i>            
	    String sentence = <font color="#BC8F8F"><b>""</b></font>;
	    <b><font color="#A020F0">while</font></b> (<b><font color="#A020F0">true</font></b>){
		sentence = (sentence + <font color="#BC8F8F"><b>" "</b></font> + s.nextLine()).trim();
		<b><font color="#A020F0">if</font></b> (sentence.equals(<font color="#BC8F8F"><b>"#"</b></font>)) <b><font color="#A020F0">return</font></b>;
		<b><font color="#A020F0">if</font></b> (sentence.charAt(sentence.length()-1) == <font color="#BC8F8F"><b>'.'</b></font>) <b><font color="#A020F0">break</font></b>;		
	    }

            <i><font color="#B22222">// now, we remove the period, and match the regular expression
</font></i>
            String removed_period = sentence.substring(0, sentence.length()-1).trim();
	    <b><font color="#A020F0">if</font></b> (pattern.matcher (removed_period).find()){
		System.out.println (<font color="#BC8F8F"><b>"Good"</b></font>);
	    } <b><font color="#A020F0">else</font></b> {
		System.out.println (<font color="#BC8F8F"><b>"Bad!"</b></font>);
	    }
	}
    }
}
</pre>
<hr>
</a><a name="file26">
<h1>Primes.cc 26/27</h1>
<pre><i><font color="#B22222">// O(sqrt(x)) Exhaustive Primality Test
</font></i>#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;cmath&gt;</b></font>
#<b><font color="#5F9EA0">define</font></b> <font color="#B8860B">EPS</font> 1e-7
<font color="#228B22"><b>typedef</b></font> <font color="#228B22"><b>long</b></font> <font color="#228B22"><b>long</b></font> LL;
<font color="#228B22"><b>bool</b></font> <b><font color="#0000FF">IsPrimeSlow</font></b> (LL x)
{
  <b><font color="#A020F0">if</font></b>(x&lt;=1) <b><font color="#A020F0">return</font></b> false;
  <b><font color="#A020F0">if</font></b>(x&lt;=3) <b><font color="#A020F0">return</font></b> true;
  <b><font color="#A020F0">if</font></b> (!(x%2) || !(x%3)) <b><font color="#A020F0">return</font></b> false;
  LL s=(LL)(sqrt((<font color="#228B22"><b>double</b></font>)(x))+EPS);
  <b><font color="#A020F0">for</font></b>(LL i=5;i&lt;=s;i+=6)
  {
    <b><font color="#A020F0">if</font></b> (!(x%i) || !(x%(i+2))) <b><font color="#A020F0">return</font></b> false;
  }
  <b><font color="#A020F0">return</font></b> true;
}
<i><font color="#B22222">// Primes less than 1000:
</font></i><i><font color="#B22222">//      2     3     5     7    11    13    17    19    23    29    31    37
</font></i><i><font color="#B22222">//     41    43    47    53    59    61    67    71    73    79    83    89
</font></i><i><font color="#B22222">//     97   101   103   107   109   113   127   131   137   139   149   151
</font></i><i><font color="#B22222">//    157   163   167   173   179   181   191   193   197   199   211   223
</font></i><i><font color="#B22222">//    227   229   233   239   241   251   257   263   269   271   277   281
</font></i><i><font color="#B22222">//    283   293   307   311   313   317   331   337   347   349   353   359
</font></i><i><font color="#B22222">//    367   373   379   383   389   397   401   409   419   421   431   433
</font></i><i><font color="#B22222">//    439   443   449   457   461   463   467   479   487   491   499   503
</font></i><i><font color="#B22222">//    509   521   523   541   547   557   563   569   571   577   587   593
</font></i><i><font color="#B22222">//    599   601   607   613   617   619   631   641   643   647   653   659
</font></i><i><font color="#B22222">//    661   673   677   683   691   701   709   719   727   733   739   743
</font></i><i><font color="#B22222">//    751   757   761   769   773   787   797   809   811   821   823   827
</font></i><i><font color="#B22222">//    829   839   853   857   859   863   877   881   883   887   907   911
</font></i><i><font color="#B22222">//    919   929   937   941   947   953   967   971   977   983   991   997
</font></i>
<i><font color="#B22222">// Other primes:
</font></i><i><font color="#B22222">//    The largest prime smaller than 10 is 7.
</font></i><i><font color="#B22222">//    The largest prime smaller than 100 is 97.
</font></i><i><font color="#B22222">//    The largest prime smaller than 1000 is 997.
</font></i><i><font color="#B22222">//    The largest prime smaller than 10000 is 9973.
</font></i><i><font color="#B22222">//    The largest prime smaller than 100000 is 99991.
</font></i><i><font color="#B22222">//    The largest prime smaller than 1000000 is 999983.
</font></i><i><font color="#B22222">//    The largest prime smaller than 10000000 is 9999991.
</font></i><i><font color="#B22222">//    The largest prime smaller than 100000000 is 99999989.
</font></i><i><font color="#B22222">//    The largest prime smaller than 1000000000 is 999999937.
</font></i><i><font color="#B22222">//    The largest prime smaller than 10000000000 is 9999999967.
</font></i><i><font color="#B22222">//    The largest prime smaller than 100000000000 is 99999999977.
</font></i><i><font color="#B22222">//    The largest prime smaller than 1000000000000 is 999999999989.
</font></i><i><font color="#B22222">//    The largest prime smaller than 10000000000000 is 9999999999971.
</font></i><i><font color="#B22222">//    The largest prime smaller than 100000000000000 is 99999999999973.
</font></i><i><font color="#B22222">//    The largest prime smaller than 1000000000000000 is 999999999999989.
</font></i><i><font color="#B22222">//    The largest prime smaller than 10000000000000000 is 9999999999999937.
</font></i><i><font color="#B22222">//    The largest prime smaller than 100000000000000000 is 99999999999999997.
</font></i><i><font color="#B22222">//    The largest prime smaller than 1000000000000000000 is 999999999999999989.
</font></i></pre>
<hr>
</a><a name="file27">
<h1>KMP.cpp 27/27</h1>
<pre><i><font color="#B22222">/*
Searches for the string w in the string s (of length k). Returns the
0-based index of the first match (k if no match is found). Algorithm
runs in O(k) time.
*/</font></i>

#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;iostream&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;string&gt;</b></font>
#<b><font color="#5F9EA0">include</font></b> <font color="#BC8F8F"><b>&lt;vector&gt;</b></font>

using namespace std;

<font color="#228B22"><b>typedef</b></font> vector&lt;<font color="#228B22"><b>int</b></font>&gt; VI;

<font color="#228B22"><b>void</b></font> <b><font color="#0000FF">buildTable</font></b>(string&amp; w, VI&amp; t)
{
  t = VI(w.length());  
  <font color="#228B22"><b>int</b></font> i = 2, j = 0;
  t[0] = -1; t[1] = 0;
  
  <b><font color="#A020F0">while</font></b>(i &lt; w.length())
  {
    <b><font color="#A020F0">if</font></b>(w[i-1] == w[j]) { t[i] = j+1; i++; j++; }
    <b><font color="#A020F0">else</font></b> <b><font color="#A020F0">if</font></b>(j &gt; 0) j = t[j];
    <b><font color="#A020F0">else</font></b> { t[i] = 0; i++; }
  }
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">KMP</font></b>(string&amp; s, string&amp; w)
{
  <font color="#228B22"><b>int</b></font> m = 0, i = 0;
  VI t;
  
  buildTable(w, t);  
  <b><font color="#A020F0">while</font></b>(m+i &lt; s.length())
  {
    <b><font color="#A020F0">if</font></b>(w[i] == s[m+i])
    {
      i++;
      <b><font color="#A020F0">if</font></b>(i == w.length()) <b><font color="#A020F0">return</font></b> m;
    }
    <b><font color="#A020F0">else</font></b>
    {
      m += i-t[i];
      <b><font color="#A020F0">if</font></b>(i &gt; 0) i = t[i];
    }
  }  
  <b><font color="#A020F0">return</font></b> s.length();
}

<font color="#228B22"><b>int</b></font> <b><font color="#0000FF">main</font></b>()
{
  string a = (string) <font color="#BC8F8F"><b>"The example above illustrates the general technique for assembling "</b></font>+
    <font color="#BC8F8F"><b>"the table with a minimum of fuss. The principle is that of the overall search: "</b></font>+
    <font color="#BC8F8F"><b>"most of the work was already done in getting to the current position, so very "</b></font>+
    <font color="#BC8F8F"><b>"little needs to be done in leaving it. The only minor complication is that the "</b></font>+
    <font color="#BC8F8F"><b>"logic which is correct late in the string erroneously gives non-proper "</b></font>+
    <font color="#BC8F8F"><b>"substrings at the beginning. This necessitates some initialization code."</b></font>;
  
  string b = <font color="#BC8F8F"><b>"table"</b></font>;
  
  <font color="#228B22"><b>int</b></font> p = KMP(a, b);
  cout &lt;&lt; p &lt;&lt; <font color="#BC8F8F"><b>": "</b></font> &lt;&lt; a.substr(p, b.length()) &lt;&lt; <font color="#BC8F8F"><b>" "</b></font> &lt;&lt; b &lt;&lt; endl;
}
</pre>
<hr>
</a><address><a name="file27">Generated by </a><a href="http://www.iki.fi/%7Emtr/genscript/">GNU enscript 1.6.1</a>.</address>


</body></html>